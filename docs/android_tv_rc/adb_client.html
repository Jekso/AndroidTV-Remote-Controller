<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>AndroidTVController.android_tv_rc.adb_client API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>AndroidTVController.android_tv_rc.adb_client</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import re
import sys
import shlex
import time
import subprocess
from typing import Any
from .logger import Logger
from .key_codes import KeyCodes



class ADBClient:
 


    def __init__(self, verbose: bool=False, show_command: bool=False):
        &#34;&#34;&#34;Pythonic way to execute adb commands on Android TV devices.
        
        The ADBClient class is used to interact with the ADB command-line tool in Python, allowing for
        communication with Android TV devices in TCP Wireless mode.
        1-Before running you need Android Platform Tools installed and available on your PATH environment variable.
            `https://developer.android.com/studio/releases/platform-tools#download`
        2-Make sure your computer running the python library and the android device is on the same network.
        3-Enable the USB/Wireless/ADB debugging feature on your android TV device depending on your version &amp; get your TV IP address.
            you can follow this link `https://www.makeuseof.com/how-to-use-adb-on-android-tv/`
        
        Some important resources:
            https://developer.android.com/tools/adb
            https://developer.android.com/studio/command-line/adb
            https://technastic.com/set-up-adb-over-wifi-android/
            https://technastic.com/adb-shell-commands-list/
            https://technastic.com/adb-commands-list-adb-cheat-sheet/
            https://www.makeuseof.com/how-to-use-adb-on-android-tv/
        
        Args:
            verbose (bool): The `verbose` parameter is a boolean flag that determines whether or not to
                enable verbose logging. If set to `True`, it will display additional information during the
                execution of the code. If set to `False` (default), it will not display any additional
                information. Defaults to False.
            show_command (bool): The `show_command` parameter is a boolean flag that determines whether or
                not to display the executed ADB commands. If `show_command` is set to `True`, the executed ADB
                commands will be shown. If `show_command` is set to `False`, the executed ADB commands will.
                Defaults to False.
        &#34;&#34;&#34;
        # logs verbose 
        self.__verbose = verbose
        self.__show_command = show_command
        if self.__verbose:
            Logger.welcome(&#39;use ADB command-line tool with python.&#39;)
        
        # adb params
        self.__devices = []
        self.__selected_device = None
        self.__server_process = None
        
        # start adb server to start sending commands to devices
        self.start_server()



    
    def __execute_command(self, command_str: str, blocking: bool=True, include_selected_serial: bool=True) -&gt; Any:
        &#34;&#34;&#34;
        The function executes a shell command using the adb tool, with the option to run it in blocking
        or non-blocking mode.

        Args:
            command_str (str): The `command_str` parameter is a string that represents the shell command
                to be executed. It can be any valid adb command or a combination of adb commands.
            blocking (bool): The `blocking` parameter is a boolean flag that determines whether the
                command should be executed synchronously (blocking) or asynchronously (non-blocking). Defaults
                to True.
            include_selected_serial (bool): Whether to include selected device serial in the command, Defaults 
                to True.

        Returns:
            The method `__execute_command` returns the output of the shell command that is executed. If
            the `blocking` parameter is set to `True`, it returns the stdout of the command as a string. If
            `blocking` is set to `False`, it returns a `subprocess.Popen` object.
            
        Raises:
            OSError: This occurs, for example, when trying to execute a non-existent file.
            ValueError: will be raised if process is called with invalid arguments.
            CalledProcessError: if the called process returns a non-zero return code.
            TimeoutExpired: if the timeout expires before the process exits.
        &#34;&#34;&#34;
        
        # adb base command
        command = &#39;adb &#39;
        
        # specify a device serial
        if self.__selected_device and include_selected_serial:
            command += f&#39;-s {self.__selected_device} &#39;
            
        # append the command to base adb
        command += command_str
        
        # show executed command if needed
        if self.__verbose and self.__show_command:
            Logger.info(f&#39;[bold]Command:[/bold] [blue]{command}[/blue]&#39;)
            
        # convert command string to list of splitted tokens
        command_parts = shlex.split(command, posix=&#34;win&#34; not in sys.platform)
        
        if blocking:
            # run the command and waits for full execution
            proc = subprocess.run(command_parts, check=True, capture_output=True, text=True)
            return proc.stdout.strip()
        else:
            # run the process in background and continue the python script
            return subprocess.Popen(command_parts, stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT)
    
    
    
    # ------------------------------[ Server Commands ]------------------------------



    def start_server(self) -&gt; bool:
        &#34;&#34;&#34;
        The function `start_server` starts an ADB server and waits for it to start up.
        
        Returns:
            Boolean indicating whether the server is running or not.
        &#34;&#34;&#34;
        Logger.info(&#39;Starting ADB server..&#39;)
        
        # start the adb server as background process
        self.__server_process = self.__execute_command(&#39;start-server&#39;, blocking=False, include_selected_serial=False)
        
        # give time to start up
        time.sleep(5)
        
        if self.__server_process:
            Logger.success(&#39;ADB server is started&#39;)
            return True
        else:
            Logger.error(f&#39;Unable to start ADB server&#39;)
            return False



    def kill_server(self) -&gt; bool:
        &#34;&#34;&#34;
        The function `kill_server` stops the ADB server and terminates any running server process.
                
        Returns:
            Boolean indicating whether the server is stopped or not.
        &#34;&#34;&#34;
        Logger.info(&#39;Stopping ADB server..&#39;)
        self.__execute_command(&#39;kill-server&#39;, include_selected_serial=False)
        if self.__server_process:
            self.__server_process.terminate()
            self.__server_process = None
            self.clean()
            Logger.success(&#39;ADB server is stopped&#39;)
            return True
        else:
            Logger.error(f&#39;No ADB server process running&#39;)
            return False
    
    
    
    def clean(self):
        &#34;&#34;&#34;Resets and clean&#34;&#34;&#34;
        Logger.info(&#39;Cleaning up&#39;)
        self.__devices = []
        self.__selected_device = None
        self.__server_process = None



    # ------------------------------[ Connectivity Commands ]------------------------------



    def connect(self, ip: str) -&gt; bool:
        &#34;&#34;&#34;
        The function connects to an IP address and raises an error if the connection fails.
        
        Args:
            ip (str): The `ip` parameter in the `connect` method is a string that represents the IP
                address of the device you want to connect.
        
        Returns:
            Boolean: True if the connection succeeded, False if the connection failed.
        &#34;&#34;&#34;
        Logger.info(f&#39;Connecting to [bold green]{ip}[/bold green] ..&#39;)
        result = self.__execute_command(f&#39;connect {ip}&#39;, include_selected_serial=False)
        if &#34;connected&#34; in result:
            self.__devices = self.get_devices()
            self.__selected_device = self.__devices[-1]
            Logger.success(f&#39;Device: [bold blue]{self.__selected_device}[/bold blue] is connected successfully&#39;)
            return True
        else: # &#34;failed&#34; in result
            Logger.error(f&#39;Connection with [bold blue]{ip}[/bold blue] failed&#39;)
            return False
    


    def is_connected(self, ip: str) -&gt; bool:
        &#34;&#34;&#34;
        The function checks if a device with a given IP address is connected to adb server.
        
        Args:
            ip (str): The `ip` parameter is a string that represents an IP address.
        
        Returns:
            Boolean value. It returns True if there is a device in the list of devices with the
            specified IP address, and False otherwise.
        &#34;&#34;&#34;
        for device in self.__devices:
            if device.split(&#39;:&#39;)[0] == ip:
                Logger.success(f&#39;Device: [bold blue]{ip}[/bold blue] is connected&#39;)
                return True
        Logger.error(f&#39;Device [bold blue]{ip}[/bold blue] is not connected&#39;)
        return False



    def disconnect(self) -&gt; bool:
        &#34;&#34;&#34;
        Disconnect selected device.
        
        Returns:
            Boolean: True if the device is disconnected.
        &#34;&#34;&#34;
        Logger.info(f&#39;Disconnecting device..&#39;)
        if &#39;disconnected&#39; in self.__execute_command(&#39;disconnect&#39;):
            self.__devices = self.get_devices()
            self.__selected_device = None
            Logger.success(f&#39;Device: [bold blue]{self.__selected_device}[/bold blue] is disconnected&#39;)
            return True
        else:
            Logger.error(f&#39;Error while disconnecting device: [bold blue]{self.__selected_device}[/bold blue]&#39;)
            return False


 
    # ------------------------------[ Info Commands ]------------------------------
    
    
    
    def get_devices(self, include_descriptions: bool=True) -&gt; list:
        &#34;&#34;&#34;
        The function `get_devices` retrieves a list of connected devices, including their IP address,
        serial number, state, and optional descriptions.
        
        Args:
            include_descriptions (bool): The `include_descriptions` parameter is a boolean flag that
                determines whether or not to include descriptions for the connected devices. If set to `True`,
                the descriptions will be included in the returned list of devices. If set to `False`, the
                descriptions will be excluded. Defaults to True

        Returns:
            The method `get_devices` returns a list of dictionaries, where each dictionary represents a
            connected device. Each dictionary contains the following keys: &#39;ip&#39;, &#39;serial_number&#39;, &#39;state&#39;,
            and &#39;description&#39;.
        &#34;&#34;&#34;
        Logger.info(f&#39;Getting connected devices..&#39;)
        self.__devices = []
        command = &#39;devices&#39;
        if include_descriptions:
            command += &#39; -l&#39;
        result = self.__execute_command(command, include_selected_serial=False)
        devices = result.split(&#34;\n&#34;)[1:]
        Logger.info(f&#39;There are [bold green]{len(devices)}[/bold green] connected devices&#39;)
        for i, device in enumerate(devices):
            data = device.split()
            serial_number = data[0]
            self.__devices.append(serial_number)
            if self.__verbose:
                Logger.print(f&#39;[bold green]Device[/bold green] ({i+1}): [yellow]{serial_number}[/yellow]&#39;)
        return self.__devices
    
    
    
    def select_device(self, device_serial: str) -&gt; bool:
        &#34;&#34;&#34;
        The function selects a device based on its serial number.
        
        Args:
            device_serial (str): The `device_serial` parameter is a string that represents the serial
                number of a device.
        
        Returns:
            Boolean: True if the device is found and selected.
        &#34;&#34;&#34;
        if device_serial in self.__devices:
            self.__selected_device = device_serial
            Logger.success(f&#39;Selected device: [bold blue]{self.__selected_device}[/bold blue]&#39;)
            return True
        else:
            Logger.error(f&#39;Device: [bold blue]{device_serial}[/bold blue] is not found&#39;)
            return False
    
    
    
    def get_selected_device(self) -&gt; str|None:
        &#34;&#34;&#34;
        Get current selected device.
        
        Returns:
            Selected device serial number. `None` if no device found.
        &#34;&#34;&#34;
        if self.__selected_device:
            Logger.success(f&#39;Selected device: [bold blue]{self.__selected_device}[/bold blue]&#39;)
        else:
            Logger.error(f&#39;No device found&#39;)
        return self.__selected_device
        
        
        
    def get_device_info(self) -&gt; dict|None:
        &#34;&#34;&#34;
        The function `get_device_info` retrieves device information.
        
        Returns:
            Dictionary containing device information. `None` if no device found.
        &#34;&#34;&#34;
        if self.__selected_device is None:
            return
        device_info = {}
        results = self.execute_shell_command(&#39;getprop&#39;).split(&#39;\n&#39;)
        for data in results:
            match = re.match(r&#34;\[([^:]+)\]: \[([^:]+)\]&#34;, data)
            if match:
                prop = match.group(1)
                value = match.group(2)
                device_info[prop] = value
                if self.__verbose:
                    Logger.print(f&#39;[bold green]{prop}[/bold green]: [yellow]{value}[/yellow]&#39;)
        return device_info
       
       
       
    def get_state(self) -&gt; str|None:
        &#34;&#34;&#34;
        The function `get_state` returns the state of connected device.
        
        Returns:
            String represents device state. `None` if no device found.
        &#34;&#34;&#34;
        if self.__selected_device is None:
            return
        device_state = self.__execute_command(&#39;get-state&#39;)
        Logger.info(f&#39;Device: ({self.__selected_device}) state is {device_state}&#39;)
        return device_state



    def get_serialno(self) -&gt; str|None:
        &#34;&#34;&#34;
        The function `get_serialno` returns the serial number of a selected device.
        
        Returns:
            String represents device serial number of the selected device. `None` if no device found.
        &#34;&#34;&#34;
        if self.__selected_device is None:
            return
        device_serialno = self.__execute_command(&#39;get-serialno&#39;)
        Logger.info(f&#39;Device Serial number: {device_serialno}&#39;)
        return device_serialno



    def get_devpath(self) -&gt; str|None:
        &#34;&#34;&#34;
        The function `get_devpath` retrieves the device path of a connected Android device&#39;.
        
        Returns:
            String represents the device path, for example usb:1-4.3 for usb connected device. `None` if no device found.
        &#34;&#34;&#34;
        if self.__selected_device is None:
            return
        device_devpath = self.__execute_command(&#39;get-devpath&#39;)
        Logger.info(f&#39;Device dev_path: {device_devpath}&#39;)
        return device_devpath
    
    
    
    def get_ip_address(self, interface: str=&#39;wlan0&#39;) -&gt; str|None:
        &#34;&#34;&#34;
        The function `get_ip_address` returns the device IP address of a specified network interface.
        
        Args:
            interface (str): The `interface` parameter is a string that specifies the network interface to
                retrieve the IP address from. In this case, the default value is set to &#34;wlan0&#34;, which is a
                common interface name for wireless LAN connections on Linux-based systems. Defaults to wlan0
        
        Returns:
            The IP address of the selected device. `None` if no device found.
        &#34;&#34;&#34;
        if self.__selected_device is None:
            return
        device_ip = &#39;&#39;
        if result := self.execute_shell_command(f&#39;ifconfig {interface}&#39;):
            if match_obj := re.search(r&#34;inet addr:(.+)  Bcast&#34;, result, re.M | re.I):
                device_ip = match_obj[1]
                Logger.info(f&#39;Device ip: {device_ip}&#39;)
        return device_ip
    
    

    # ------------------------------[ File Operations Commands ]------------------------------



    def push(self, local: str, remote: str=&#39;/data/local/tmp/&#39;) -&gt; bool|None:
        &#34;&#34;&#34;
        Copy files and directories from the local device (computer) to
        a remote location on the device.
        
        Args:
            local (str): The `local` parameter is a string that represents the path of the file or
                directory on the local device (computer) that you want to copy to the remote location on the
                device.
            remote (str): The `remote` parameter is a string that specifies the destination location on
                the device where the files or directories from the local device will be copied to. By default,
                the destination location is set to `/data/local/tmp/`, but you can provide a different path if
                needed. Defaults to /data/local/tmp/
        
        Returns:
            Boolean indicating whether the upload operation was successful. `None` if no device found.
        &#34;&#34;&#34;
        if self.__selected_device is None:
            return
        Logger.info(f&#39;Uploading: [bold green]{local}[/bold green] to [bold green]{remote}[/bold green] ..&#39;)
        result = self.__execute_command(f&#39;push {local} {remote}&#39;) 
        if &#39;1 file pushed&#39; in result:
            Logger.success(f&#39;File [bold blue]{local}[/bold blue] uploaded to [bold blue]{remote}[/bold blue] successfully&#39;)
            return True
        else:
            Logger.error(f&#39;Uploading [bold blue]{local}[/bold blue] to [bold blue]{remote}[/bold blue] failed&#39;)
            return False
        



    def pull(self, remote: str, local: str, preserve_meta: bool=False) -&gt; bool|None:
        &#34;&#34;&#34;
        The function `pull` copies remote files and directories to a device, with an option to preserve
        file metadata like time stamp and mode.
        
        Args:
            remote (str): The `remote` parameter is a string that represents the path of the remote file
                or directory that you want to copy to the device.
            local (str): The &#34;local&#34; parameter is a string that represents the local directory or file
                path where the remote files and directories will be copied to.
            preserve_meta (bool): The `preserve_meta` parameter is a boolean flag that determines whether
                to preserve the file time stamp and mode during the file transfer process. If `preserve_meta` is
                set to `True`, the `-k` option will be added to the command, indicating that the file time stamp
                and mode should be. Defaults to False
        
        Returns:
            Boolean indicating whether the download operation was successful. `None` if no device found.
        &#34;&#34;&#34;
        if self.__selected_device is None:
            return
        command = &#39;pull &#39;
        if preserve_meta:
            command += &#39;-k &#39;
        command += f&#39;{remote} {local}&#39;
        Logger.info(f&#39;Downloading: [bold green]{remote}[/bold green] to [bold green]{local}[/bold green] ..&#39;)
        result = self.__execute_command(command)
        if &#39;1 file pulled,&#39; in result:
            Logger.success(f&#39;File [bold blue]{remote}[/bold blue] downloaded to [bold blue]{local}[/bold blue] successfully&#39;)
            return True
        else:
            Logger.error(f&#39;Downloading [bold blue]{remote}[/bold blue] to [bold blue]{local}[/bold blue] failed&#39;)
            return False


    # ------------------------------[ Apps Operations Commands ]------------------------------
    


    def is_installed(self, package_name: str) -&gt; bool|None:
        &#34;&#34;&#34;
        The function checks if the specified package is installed or not.
        
        Args:
            package_name (str): The name of the package, for example &#39;com.google.chrome&#39;
        
        Returns:
            Boolean indicates if app is installed or not. `None` if no device found.
        &#34;&#34;&#34;
        if self.__selected_device is None:
            return
        command = f&#39;pm list packages&#39;
        app_installed =  package_name in self.execute_shell_command(command)
        if app_installed:
            Logger.success(f&#39;App [bold blue]{package_name}[/bold blue] is installed&#39;)
            return True
        else:
            Logger.error(f&#39;App [bold blue]{package_name}[/bold blue] is not installed&#39;)
            return False
        
        
        
    def install(self, apk_file: str, replace: bool=True) -&gt; bool|None:
        &#34;&#34;&#34;
        The function installs an APK file on a device, with an option to replace/update an existing
        installation.
        
        Args:
            apk_file (str): The `apk_file` parameter is a string that represents the file path of the APK
                file that you want to install.
            replace (bool): The `replace` parameter is a boolean value that determines whether to replace
                an existing installation of the APK file. If `replace` is set to `True`, the existing
                installation will be replaced. If `replace` is set to `False`, the existing installation will
                not be replaced and an error will. Defaults to True
        
        Returns:
            Boolean indicates if installation process is successful. `None` if no device found.
        &#34;&#34;&#34;
        if self.__selected_device is None:
            return
        command = &#39;install &#39;
        if replace:
            command += &#39;-r &#39;
        command += apk_file
        Logger.info(f&#39;Installing APK file [bold green]{apk_file}[/bold green], it will took up to 2 minutes to complete..&#39;)
        result = self.__execute_command(command)
        if &#39;Success&#39; in result:
            Logger.success(f&#39;APK [bold blue]{apk_file}[/bold blue] is installed successfully&#39;)
            return True
        else:
            Logger.error(f&#39;Installation process failed&#39;)
            return False



    def uninstall(self, package: str, keep_data: bool=False) -&gt; bool|None:
        &#34;&#34;&#34;
        The `uninstall` function removes an app package from a device, with an option to keep the data
        and cache directories.
        
        Args:
            package (str): The package parameter is a string that represents the app package name that you
                want to uninstall from the device.
            keep_data (bool): A boolean parameter that determines whether to keep the data and cache
                directories of the app package when uninstalling. If set to True, the directories will be kept.
                If set to False (default), the directories will be removed along with the app package. Defaults
                to False
        
        Returns:
            Boolean indicates if uninstallation process is successful. `None` if no device found.
        &#34;&#34;&#34;
        if self.__selected_device is None:
            return
        command = &#39;uninstall &#39;
        if keep_data:
            command += &#39;-k &#39;
        command += package
        message = f&#39;Uninstalling package [bold green]{package}[/bold green]&#39;
        message += &#39;while keeping the data&#39; if keep_data else &#39;&#39;
        message += &#39;, it will took up to 2 minutes to complete..&#39;
        Logger.info(message)
        result = self.__execute_command(command)
        if &#39;Success&#39; in result:
            Logger.success(f&#39;Package [bold blue]{package}[/bold blue] is uninstalled successfully&#39;)
            return True
        else:
            Logger.error(f&#39;Uninstallation process failed&#39;)
            return False
    
    
    
    def start_app(self, package: str, activity: str, wait: bool=True, stop: bool=True) -&gt; bool|None:
        &#34;&#34;&#34;
        The function starts an Android app with the specified package and activity, optionally waiting
        for the launch to complete and stopping the app before starting the activity.
        
        Args:
            package (str): The package parameter is a string that represents the package name of the
                Android application you want to start. This is typically the unique identifier for the app and
                is specified in the AndroidManifest.xml file of the app.
            activity (str): The &#34;activity&#34; parameter refers to the specific activity or screen within the
                Android app that you want to start. An activity represents a single screen with a user
                interface, and it is the basic building block of an Android app. Each activity has a unique name
                that is specified in the AndroidManifest.xml file
            wait (bool): The &#34;wait&#34; parameter is a boolean value that determines whether the command
                should wait for the launch to complete before returning. If set to True, the command will wait
                for the launch to complete. If set to False, the command will not wait and will return
                immediately after starting the activity. Defaults to True
            stop (bool): The &#34;stop&#34; parameter is a boolean value that determines whether to force stop the
                target app before starting the activity. If it is set to True, the target app will be stopped
                before starting the activity. If it is set to False, the target app will not be stopped.
                Defaults to True
        
        Returns:
            Boolean indicates if app starting process is successful. `None` if no device found.
        &#34;&#34;&#34;
        if self.__selected_device is None:
            return
        # check if app is installed
        if not self.is_installed(package):
            return False
        self.send_keyevent_input(KeyCodes.KEYCODE_HOME)
        command = &#39;am start &#39;
        # wait for launch to complete
        if wait:
            command += &#39;-W &#39;
        if stop: # force stop the target app before starting the activity
            command += &#39;-S &#39;
        command += f&#39;{package}/{activity}&#39;
        Logger.info(f&#39;Starting app: [bold green]{package}[/bold green] ..&#39;)
        result = self.execute_shell_command(command)
        if &#39;Error&#39; in result:
            Logger.error(f&#39;Starting app [bold blue]{package}[/bold blue] failed&#39;)
            return False
        else:
            Logger.success(f&#39;App: [bold blue]{package}[/bold blue] started successfully&#39;)
            return True



    def stop_app(self, package: str) -&gt; bool|None:
        &#34;&#34;&#34;
        The function stops an Android app with the specified package.
        
        Args:
            package (str): The package parameter is a string that represents the package name of the app
                you want to stop.
        
        Returns:
            Boolean indicates if app stopping process is successful. `None` if no device found.
        &#34;&#34;&#34;
        if self.__selected_device is None:
            return
        Logger.info(f&#39;Stopping app: [bold green]{package}[/bold green] ..&#39;)
        result =  self.execute_shell_command(f&#39;am force-stop {package}&#39;)
        if &#39;Error&#39; in result:
            Logger.error(f&#39;Stopping app [bold blue]{package}[/bold blue] failed&#39;)
            return False
        else:
            Logger.success(f&#39;App: [bold blue]{package}[/bold blue] stopped successfully&#39;)
            return True



    def list_packages(self, package_type: str=&#39;all&#39;) -&gt; list|None:
        &#34;&#34;&#34;
        The function &#34;list_packages&#34; lists device android packages, you can also filter package type.
        
        Args:
            package_type (str): The `package_type` parameter is a string that specifies the type of
                packages to list. It has a default value of `all` that gets all packages on the device,
                but it can also take the following values: [all | enabled | disabled | system | third-party].
                Defaults to all
        
        Returns:
            List of packages. `None` if no device found.
        &#34;&#34;&#34;
        if self.__selected_device is None:
            return
        packages = []
        if self.__selected_device:
            package_type_flags = {&#39;all&#39;: &#39;&#39;, &#39;enabled&#39;: &#39;-e&#39;, &#39;disabled&#39;: &#39;-d&#39;, &#39;system&#39;: &#39;-s&#39;, &#39;third-party&#39;: &#39;-3&#39;}
            if package_type not in package_type_flags:
                package_type = &#39;all&#39;
            results = self.execute_shell_command(f&#39;pm list packages {package_type_flags[package_type]}&#39;).split(&#34;\n&#34;)
            packages = sorted([x.replace(&#39;package:&#39;, &#39;&#39;) for x in results])
            Logger.info(f&#39;There are [bold green]{len(packages)}[/bold green] [bold blue]{package_type}[/bold blue] packages&#39;)
            if self.__verbose:
                for package in packages:
                    Logger.print(f&#39;[bold green]{package}[/bold green]&#39;)
        return packages
    
    
    
    def get_package_activities(self, package: str) -&gt; list|None:
        &#34;&#34;&#34;
        The function `get_package_activities` retrieves the activities associated with a given package
        in order to start the app. this is useful to be able to start the app
        
        Args:
            package (str): The &#34;package&#34; parameter is a string that represents the name of the package for
                which you want to retrieve the activities.
        
        Returns:
            List of package activities. `None` if no device found.
        &#34;&#34;&#34;
        if self.__selected_device is None:
            return
        results = self.execute_shell_command(f&#39;dumpsys package {package}&#39;).split()
        activities = []
        for res in results:
            if f&#39;{package}/&#39; in res:
                activity = res.replace(&#39;&#34;&#39;, &#39;&#39;).replace(&#39;:&#39;, &#39;&#39;).replace(&#39;}&#39;, &#39;&#39;).strip()
                activities.append(activity)
                if self.__verbose:
                    Logger.print(f&#39;[bold green]{activity}[/bold green]&#39;)
        unique_activities = []
        for activity in activities:
            if activity not in unique_activities and activity.startswith(package):
                unique_activities.append(activity) 
        Logger.info(f&#39;There are [bold green]{len(unique_activities)}[/bold green] activities for package: {package}&#39;)
        return unique_activities



    # ------------------------------[ Device related Commands ]------------------------------



    def reboot(self, mode: str|None=None) -&gt; bool|None:
        &#34;&#34;&#34;
        The function `reboot` reboots the device with the specified mode, or with no mode if none is
        provided.
        
        Args:
            mode (str|None): The `mode` parameter is a string that specifies the type of reboot to
                perform. It can have one of the following values: [bootloader | recovery | sideload | sideload-auto-reboot]
        
        Returns:
            Boolean indicates if tv is rebooted successfully. `None` if no device found.
        &#34;&#34;&#34;
        if self.__selected_device is None:
            return
        command = &#39;reboot &#39;
        if mode:
            command += mode
        Logger.info(f&#39;Rebooting TV&#39; + f&#39; in mode [bold green]{mode}[bold green]&#39; if mode else &#39;&#39; + &#39; ..&#39;)
        result =  self.__execute_command(command)
        if &#39;error&#39; in result:
            Logger.error(f&#39;Rebooting failed&#39;)
            return False
        else:
            Logger.success(f&#39;Rebooted successfully&#39;)
            return True
    
    
    
    def execute_shell_command(self, command: str) -&gt; str:
        &#34;&#34;&#34;
        The function executes an adb shell command by calling `adb shell` command.
        
        Args:
            command (str): The `command` parameter is a string that represents the shell command that you
                want to execute.
        
        Returns:
            String of the output results of executing the shell command.
        &#34;&#34;&#34;
        return self.__execute_command(f&#39;shell {command}&#39;)



    # ------------------------------[ Inputs Commands ]------------------------------



    def send_keyevent_input(self, keycode: KeyCodes, long_press: bool=False):
        &#34;&#34;&#34;
        The function executes an adb shell command to send key event input that simulates pressing button keys.
        
        Args:
            keycode (KeyCode): the keycode to send, table of key codes: https://www.temblast.com/ref/akeyscode.htm
            long_press (bool): specify if simulate a long press for the key or not. Defaults to False.
        &#34;&#34;&#34;
        if self.__selected_device is None:
            return
        command = f&#39;input keyevent {keycode.name}&#39;
        if long_press:
            command += &#39; --longpress&#39;
        self.execute_shell_command(command)
    
    
    
    def send_text_input(self, text: str, encode_spaces: bool=True):
        &#34;&#34;&#34;
        The function executes an adb shell command to send text input.
        
        Args:
            text (str): the text string to send.
            encode_spaces (bool): specify if spaces should be replaced by `%s` or not. Defaults to True.
        &#34;&#34;&#34;
        if self.__selected_device is None:
            return
        processed_text = text.replace(&#39; &#39;, &#39;%s&#39;) if encode_spaces else text
        self.execute_shell_command(f&#39;input text {processed_text}&#39;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="AndroidTVController.android_tv_rc.adb_client.ADBClient"><code class="flex name class">
<span>class <span class="ident">ADBClient</span></span>
<span>(</span><span>verbose: bool = False, show_command: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Pythonic way to execute adb commands on Android TV devices.</p>
<p>The ADBClient class is used to interact with the ADB command-line tool in Python, allowing for
communication with Android TV devices in TCP Wireless mode.
1-Before running you need Android Platform Tools installed and available on your PATH environment variable.
<code>https://developer.android.com/studio/releases/platform-tools#download</code>
2-Make sure your computer running the python library and the android device is on the same network.
3-Enable the USB/Wireless/ADB debugging feature on your android TV device depending on your version &amp; get your TV IP address.
you can follow this link <code>https://www.makeuseof.com/how-to-use-adb-on-android-tv/</code></p>
<p>Some important resources:
<a href="https://developer.android.com/tools/adb">https://developer.android.com/tools/adb</a>
<a href="https://developer.android.com/studio/command-line/adb">https://developer.android.com/studio/command-line/adb</a>
<a href="https://technastic.com/set-up-adb-over-wifi-android/">https://technastic.com/set-up-adb-over-wifi-android/</a>
<a href="https://technastic.com/adb-shell-commands-list/">https://technastic.com/adb-shell-commands-list/</a>
<a href="https://technastic.com/adb-commands-list-adb-cheat-sheet/">https://technastic.com/adb-commands-list-adb-cheat-sheet/</a>
<a href="https://www.makeuseof.com/how-to-use-adb-on-android-tv/">https://www.makeuseof.com/how-to-use-adb-on-android-tv/</a></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code></dt>
<dd>The <code>verbose</code> parameter is a boolean flag that determines whether or not to
enable verbose logging. If set to <code>True</code>, it will display additional information during the
execution of the code. If set to <code>False</code> (default), it will not display any additional
information. Defaults to False.</dd>
<dt><strong><code>show_command</code></strong> :&ensp;<code>bool</code></dt>
<dd>The <code>show_command</code> parameter is a boolean flag that determines whether or
not to display the executed ADB commands. If <code>show_command</code> is set to <code>True</code>, the executed ADB
commands will be shown. If <code>show_command</code> is set to <code>False</code>, the executed ADB commands will.
Defaults to False.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ADBClient:
 


    def __init__(self, verbose: bool=False, show_command: bool=False):
        &#34;&#34;&#34;Pythonic way to execute adb commands on Android TV devices.
        
        The ADBClient class is used to interact with the ADB command-line tool in Python, allowing for
        communication with Android TV devices in TCP Wireless mode.
        1-Before running you need Android Platform Tools installed and available on your PATH environment variable.
            `https://developer.android.com/studio/releases/platform-tools#download`
        2-Make sure your computer running the python library and the android device is on the same network.
        3-Enable the USB/Wireless/ADB debugging feature on your android TV device depending on your version &amp; get your TV IP address.
            you can follow this link `https://www.makeuseof.com/how-to-use-adb-on-android-tv/`
        
        Some important resources:
            https://developer.android.com/tools/adb
            https://developer.android.com/studio/command-line/adb
            https://technastic.com/set-up-adb-over-wifi-android/
            https://technastic.com/adb-shell-commands-list/
            https://technastic.com/adb-commands-list-adb-cheat-sheet/
            https://www.makeuseof.com/how-to-use-adb-on-android-tv/
        
        Args:
            verbose (bool): The `verbose` parameter is a boolean flag that determines whether or not to
                enable verbose logging. If set to `True`, it will display additional information during the
                execution of the code. If set to `False` (default), it will not display any additional
                information. Defaults to False.
            show_command (bool): The `show_command` parameter is a boolean flag that determines whether or
                not to display the executed ADB commands. If `show_command` is set to `True`, the executed ADB
                commands will be shown. If `show_command` is set to `False`, the executed ADB commands will.
                Defaults to False.
        &#34;&#34;&#34;
        # logs verbose 
        self.__verbose = verbose
        self.__show_command = show_command
        if self.__verbose:
            Logger.welcome(&#39;use ADB command-line tool with python.&#39;)
        
        # adb params
        self.__devices = []
        self.__selected_device = None
        self.__server_process = None
        
        # start adb server to start sending commands to devices
        self.start_server()



    
    def __execute_command(self, command_str: str, blocking: bool=True, include_selected_serial: bool=True) -&gt; Any:
        &#34;&#34;&#34;
        The function executes a shell command using the adb tool, with the option to run it in blocking
        or non-blocking mode.

        Args:
            command_str (str): The `command_str` parameter is a string that represents the shell command
                to be executed. It can be any valid adb command or a combination of adb commands.
            blocking (bool): The `blocking` parameter is a boolean flag that determines whether the
                command should be executed synchronously (blocking) or asynchronously (non-blocking). Defaults
                to True.
            include_selected_serial (bool): Whether to include selected device serial in the command, Defaults 
                to True.

        Returns:
            The method `__execute_command` returns the output of the shell command that is executed. If
            the `blocking` parameter is set to `True`, it returns the stdout of the command as a string. If
            `blocking` is set to `False`, it returns a `subprocess.Popen` object.
            
        Raises:
            OSError: This occurs, for example, when trying to execute a non-existent file.
            ValueError: will be raised if process is called with invalid arguments.
            CalledProcessError: if the called process returns a non-zero return code.
            TimeoutExpired: if the timeout expires before the process exits.
        &#34;&#34;&#34;
        
        # adb base command
        command = &#39;adb &#39;
        
        # specify a device serial
        if self.__selected_device and include_selected_serial:
            command += f&#39;-s {self.__selected_device} &#39;
            
        # append the command to base adb
        command += command_str
        
        # show executed command if needed
        if self.__verbose and self.__show_command:
            Logger.info(f&#39;[bold]Command:[/bold] [blue]{command}[/blue]&#39;)
            
        # convert command string to list of splitted tokens
        command_parts = shlex.split(command, posix=&#34;win&#34; not in sys.platform)
        
        if blocking:
            # run the command and waits for full execution
            proc = subprocess.run(command_parts, check=True, capture_output=True, text=True)
            return proc.stdout.strip()
        else:
            # run the process in background and continue the python script
            return subprocess.Popen(command_parts, stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT)
    
    
    
    # ------------------------------[ Server Commands ]------------------------------



    def start_server(self) -&gt; bool:
        &#34;&#34;&#34;
        The function `start_server` starts an ADB server and waits for it to start up.
        
        Returns:
            Boolean indicating whether the server is running or not.
        &#34;&#34;&#34;
        Logger.info(&#39;Starting ADB server..&#39;)
        
        # start the adb server as background process
        self.__server_process = self.__execute_command(&#39;start-server&#39;, blocking=False, include_selected_serial=False)
        
        # give time to start up
        time.sleep(5)
        
        if self.__server_process:
            Logger.success(&#39;ADB server is started&#39;)
            return True
        else:
            Logger.error(f&#39;Unable to start ADB server&#39;)
            return False



    def kill_server(self) -&gt; bool:
        &#34;&#34;&#34;
        The function `kill_server` stops the ADB server and terminates any running server process.
                
        Returns:
            Boolean indicating whether the server is stopped or not.
        &#34;&#34;&#34;
        Logger.info(&#39;Stopping ADB server..&#39;)
        self.__execute_command(&#39;kill-server&#39;, include_selected_serial=False)
        if self.__server_process:
            self.__server_process.terminate()
            self.__server_process = None
            self.clean()
            Logger.success(&#39;ADB server is stopped&#39;)
            return True
        else:
            Logger.error(f&#39;No ADB server process running&#39;)
            return False
    
    
    
    def clean(self):
        &#34;&#34;&#34;Resets and clean&#34;&#34;&#34;
        Logger.info(&#39;Cleaning up&#39;)
        self.__devices = []
        self.__selected_device = None
        self.__server_process = None



    # ------------------------------[ Connectivity Commands ]------------------------------



    def connect(self, ip: str) -&gt; bool:
        &#34;&#34;&#34;
        The function connects to an IP address and raises an error if the connection fails.
        
        Args:
            ip (str): The `ip` parameter in the `connect` method is a string that represents the IP
                address of the device you want to connect.
        
        Returns:
            Boolean: True if the connection succeeded, False if the connection failed.
        &#34;&#34;&#34;
        Logger.info(f&#39;Connecting to [bold green]{ip}[/bold green] ..&#39;)
        result = self.__execute_command(f&#39;connect {ip}&#39;, include_selected_serial=False)
        if &#34;connected&#34; in result:
            self.__devices = self.get_devices()
            self.__selected_device = self.__devices[-1]
            Logger.success(f&#39;Device: [bold blue]{self.__selected_device}[/bold blue] is connected successfully&#39;)
            return True
        else: # &#34;failed&#34; in result
            Logger.error(f&#39;Connection with [bold blue]{ip}[/bold blue] failed&#39;)
            return False
    


    def is_connected(self, ip: str) -&gt; bool:
        &#34;&#34;&#34;
        The function checks if a device with a given IP address is connected to adb server.
        
        Args:
            ip (str): The `ip` parameter is a string that represents an IP address.
        
        Returns:
            Boolean value. It returns True if there is a device in the list of devices with the
            specified IP address, and False otherwise.
        &#34;&#34;&#34;
        for device in self.__devices:
            if device.split(&#39;:&#39;)[0] == ip:
                Logger.success(f&#39;Device: [bold blue]{ip}[/bold blue] is connected&#39;)
                return True
        Logger.error(f&#39;Device [bold blue]{ip}[/bold blue] is not connected&#39;)
        return False



    def disconnect(self) -&gt; bool:
        &#34;&#34;&#34;
        Disconnect selected device.
        
        Returns:
            Boolean: True if the device is disconnected.
        &#34;&#34;&#34;
        Logger.info(f&#39;Disconnecting device..&#39;)
        if &#39;disconnected&#39; in self.__execute_command(&#39;disconnect&#39;):
            self.__devices = self.get_devices()
            self.__selected_device = None
            Logger.success(f&#39;Device: [bold blue]{self.__selected_device}[/bold blue] is disconnected&#39;)
            return True
        else:
            Logger.error(f&#39;Error while disconnecting device: [bold blue]{self.__selected_device}[/bold blue]&#39;)
            return False


 
    # ------------------------------[ Info Commands ]------------------------------
    
    
    
    def get_devices(self, include_descriptions: bool=True) -&gt; list:
        &#34;&#34;&#34;
        The function `get_devices` retrieves a list of connected devices, including their IP address,
        serial number, state, and optional descriptions.
        
        Args:
            include_descriptions (bool): The `include_descriptions` parameter is a boolean flag that
                determines whether or not to include descriptions for the connected devices. If set to `True`,
                the descriptions will be included in the returned list of devices. If set to `False`, the
                descriptions will be excluded. Defaults to True

        Returns:
            The method `get_devices` returns a list of dictionaries, where each dictionary represents a
            connected device. Each dictionary contains the following keys: &#39;ip&#39;, &#39;serial_number&#39;, &#39;state&#39;,
            and &#39;description&#39;.
        &#34;&#34;&#34;
        Logger.info(f&#39;Getting connected devices..&#39;)
        self.__devices = []
        command = &#39;devices&#39;
        if include_descriptions:
            command += &#39; -l&#39;
        result = self.__execute_command(command, include_selected_serial=False)
        devices = result.split(&#34;\n&#34;)[1:]
        Logger.info(f&#39;There are [bold green]{len(devices)}[/bold green] connected devices&#39;)
        for i, device in enumerate(devices):
            data = device.split()
            serial_number = data[0]
            self.__devices.append(serial_number)
            if self.__verbose:
                Logger.print(f&#39;[bold green]Device[/bold green] ({i+1}): [yellow]{serial_number}[/yellow]&#39;)
        return self.__devices
    
    
    
    def select_device(self, device_serial: str) -&gt; bool:
        &#34;&#34;&#34;
        The function selects a device based on its serial number.
        
        Args:
            device_serial (str): The `device_serial` parameter is a string that represents the serial
                number of a device.
        
        Returns:
            Boolean: True if the device is found and selected.
        &#34;&#34;&#34;
        if device_serial in self.__devices:
            self.__selected_device = device_serial
            Logger.success(f&#39;Selected device: [bold blue]{self.__selected_device}[/bold blue]&#39;)
            return True
        else:
            Logger.error(f&#39;Device: [bold blue]{device_serial}[/bold blue] is not found&#39;)
            return False
    
    
    
    def get_selected_device(self) -&gt; str|None:
        &#34;&#34;&#34;
        Get current selected device.
        
        Returns:
            Selected device serial number. `None` if no device found.
        &#34;&#34;&#34;
        if self.__selected_device:
            Logger.success(f&#39;Selected device: [bold blue]{self.__selected_device}[/bold blue]&#39;)
        else:
            Logger.error(f&#39;No device found&#39;)
        return self.__selected_device
        
        
        
    def get_device_info(self) -&gt; dict|None:
        &#34;&#34;&#34;
        The function `get_device_info` retrieves device information.
        
        Returns:
            Dictionary containing device information. `None` if no device found.
        &#34;&#34;&#34;
        if self.__selected_device is None:
            return
        device_info = {}
        results = self.execute_shell_command(&#39;getprop&#39;).split(&#39;\n&#39;)
        for data in results:
            match = re.match(r&#34;\[([^:]+)\]: \[([^:]+)\]&#34;, data)
            if match:
                prop = match.group(1)
                value = match.group(2)
                device_info[prop] = value
                if self.__verbose:
                    Logger.print(f&#39;[bold green]{prop}[/bold green]: [yellow]{value}[/yellow]&#39;)
        return device_info
       
       
       
    def get_state(self) -&gt; str|None:
        &#34;&#34;&#34;
        The function `get_state` returns the state of connected device.
        
        Returns:
            String represents device state. `None` if no device found.
        &#34;&#34;&#34;
        if self.__selected_device is None:
            return
        device_state = self.__execute_command(&#39;get-state&#39;)
        Logger.info(f&#39;Device: ({self.__selected_device}) state is {device_state}&#39;)
        return device_state



    def get_serialno(self) -&gt; str|None:
        &#34;&#34;&#34;
        The function `get_serialno` returns the serial number of a selected device.
        
        Returns:
            String represents device serial number of the selected device. `None` if no device found.
        &#34;&#34;&#34;
        if self.__selected_device is None:
            return
        device_serialno = self.__execute_command(&#39;get-serialno&#39;)
        Logger.info(f&#39;Device Serial number: {device_serialno}&#39;)
        return device_serialno



    def get_devpath(self) -&gt; str|None:
        &#34;&#34;&#34;
        The function `get_devpath` retrieves the device path of a connected Android device&#39;.
        
        Returns:
            String represents the device path, for example usb:1-4.3 for usb connected device. `None` if no device found.
        &#34;&#34;&#34;
        if self.__selected_device is None:
            return
        device_devpath = self.__execute_command(&#39;get-devpath&#39;)
        Logger.info(f&#39;Device dev_path: {device_devpath}&#39;)
        return device_devpath
    
    
    
    def get_ip_address(self, interface: str=&#39;wlan0&#39;) -&gt; str|None:
        &#34;&#34;&#34;
        The function `get_ip_address` returns the device IP address of a specified network interface.
        
        Args:
            interface (str): The `interface` parameter is a string that specifies the network interface to
                retrieve the IP address from. In this case, the default value is set to &#34;wlan0&#34;, which is a
                common interface name for wireless LAN connections on Linux-based systems. Defaults to wlan0
        
        Returns:
            The IP address of the selected device. `None` if no device found.
        &#34;&#34;&#34;
        if self.__selected_device is None:
            return
        device_ip = &#39;&#39;
        if result := self.execute_shell_command(f&#39;ifconfig {interface}&#39;):
            if match_obj := re.search(r&#34;inet addr:(.+)  Bcast&#34;, result, re.M | re.I):
                device_ip = match_obj[1]
                Logger.info(f&#39;Device ip: {device_ip}&#39;)
        return device_ip
    
    

    # ------------------------------[ File Operations Commands ]------------------------------



    def push(self, local: str, remote: str=&#39;/data/local/tmp/&#39;) -&gt; bool|None:
        &#34;&#34;&#34;
        Copy files and directories from the local device (computer) to
        a remote location on the device.
        
        Args:
            local (str): The `local` parameter is a string that represents the path of the file or
                directory on the local device (computer) that you want to copy to the remote location on the
                device.
            remote (str): The `remote` parameter is a string that specifies the destination location on
                the device where the files or directories from the local device will be copied to. By default,
                the destination location is set to `/data/local/tmp/`, but you can provide a different path if
                needed. Defaults to /data/local/tmp/
        
        Returns:
            Boolean indicating whether the upload operation was successful. `None` if no device found.
        &#34;&#34;&#34;
        if self.__selected_device is None:
            return
        Logger.info(f&#39;Uploading: [bold green]{local}[/bold green] to [bold green]{remote}[/bold green] ..&#39;)
        result = self.__execute_command(f&#39;push {local} {remote}&#39;) 
        if &#39;1 file pushed&#39; in result:
            Logger.success(f&#39;File [bold blue]{local}[/bold blue] uploaded to [bold blue]{remote}[/bold blue] successfully&#39;)
            return True
        else:
            Logger.error(f&#39;Uploading [bold blue]{local}[/bold blue] to [bold blue]{remote}[/bold blue] failed&#39;)
            return False
        



    def pull(self, remote: str, local: str, preserve_meta: bool=False) -&gt; bool|None:
        &#34;&#34;&#34;
        The function `pull` copies remote files and directories to a device, with an option to preserve
        file metadata like time stamp and mode.
        
        Args:
            remote (str): The `remote` parameter is a string that represents the path of the remote file
                or directory that you want to copy to the device.
            local (str): The &#34;local&#34; parameter is a string that represents the local directory or file
                path where the remote files and directories will be copied to.
            preserve_meta (bool): The `preserve_meta` parameter is a boolean flag that determines whether
                to preserve the file time stamp and mode during the file transfer process. If `preserve_meta` is
                set to `True`, the `-k` option will be added to the command, indicating that the file time stamp
                and mode should be. Defaults to False
        
        Returns:
            Boolean indicating whether the download operation was successful. `None` if no device found.
        &#34;&#34;&#34;
        if self.__selected_device is None:
            return
        command = &#39;pull &#39;
        if preserve_meta:
            command += &#39;-k &#39;
        command += f&#39;{remote} {local}&#39;
        Logger.info(f&#39;Downloading: [bold green]{remote}[/bold green] to [bold green]{local}[/bold green] ..&#39;)
        result = self.__execute_command(command)
        if &#39;1 file pulled,&#39; in result:
            Logger.success(f&#39;File [bold blue]{remote}[/bold blue] downloaded to [bold blue]{local}[/bold blue] successfully&#39;)
            return True
        else:
            Logger.error(f&#39;Downloading [bold blue]{remote}[/bold blue] to [bold blue]{local}[/bold blue] failed&#39;)
            return False


    # ------------------------------[ Apps Operations Commands ]------------------------------
    


    def is_installed(self, package_name: str) -&gt; bool|None:
        &#34;&#34;&#34;
        The function checks if the specified package is installed or not.
        
        Args:
            package_name (str): The name of the package, for example &#39;com.google.chrome&#39;
        
        Returns:
            Boolean indicates if app is installed or not. `None` if no device found.
        &#34;&#34;&#34;
        if self.__selected_device is None:
            return
        command = f&#39;pm list packages&#39;
        app_installed =  package_name in self.execute_shell_command(command)
        if app_installed:
            Logger.success(f&#39;App [bold blue]{package_name}[/bold blue] is installed&#39;)
            return True
        else:
            Logger.error(f&#39;App [bold blue]{package_name}[/bold blue] is not installed&#39;)
            return False
        
        
        
    def install(self, apk_file: str, replace: bool=True) -&gt; bool|None:
        &#34;&#34;&#34;
        The function installs an APK file on a device, with an option to replace/update an existing
        installation.
        
        Args:
            apk_file (str): The `apk_file` parameter is a string that represents the file path of the APK
                file that you want to install.
            replace (bool): The `replace` parameter is a boolean value that determines whether to replace
                an existing installation of the APK file. If `replace` is set to `True`, the existing
                installation will be replaced. If `replace` is set to `False`, the existing installation will
                not be replaced and an error will. Defaults to True
        
        Returns:
            Boolean indicates if installation process is successful. `None` if no device found.
        &#34;&#34;&#34;
        if self.__selected_device is None:
            return
        command = &#39;install &#39;
        if replace:
            command += &#39;-r &#39;
        command += apk_file
        Logger.info(f&#39;Installing APK file [bold green]{apk_file}[/bold green], it will took up to 2 minutes to complete..&#39;)
        result = self.__execute_command(command)
        if &#39;Success&#39; in result:
            Logger.success(f&#39;APK [bold blue]{apk_file}[/bold blue] is installed successfully&#39;)
            return True
        else:
            Logger.error(f&#39;Installation process failed&#39;)
            return False



    def uninstall(self, package: str, keep_data: bool=False) -&gt; bool|None:
        &#34;&#34;&#34;
        The `uninstall` function removes an app package from a device, with an option to keep the data
        and cache directories.
        
        Args:
            package (str): The package parameter is a string that represents the app package name that you
                want to uninstall from the device.
            keep_data (bool): A boolean parameter that determines whether to keep the data and cache
                directories of the app package when uninstalling. If set to True, the directories will be kept.
                If set to False (default), the directories will be removed along with the app package. Defaults
                to False
        
        Returns:
            Boolean indicates if uninstallation process is successful. `None` if no device found.
        &#34;&#34;&#34;
        if self.__selected_device is None:
            return
        command = &#39;uninstall &#39;
        if keep_data:
            command += &#39;-k &#39;
        command += package
        message = f&#39;Uninstalling package [bold green]{package}[/bold green]&#39;
        message += &#39;while keeping the data&#39; if keep_data else &#39;&#39;
        message += &#39;, it will took up to 2 minutes to complete..&#39;
        Logger.info(message)
        result = self.__execute_command(command)
        if &#39;Success&#39; in result:
            Logger.success(f&#39;Package [bold blue]{package}[/bold blue] is uninstalled successfully&#39;)
            return True
        else:
            Logger.error(f&#39;Uninstallation process failed&#39;)
            return False
    
    
    
    def start_app(self, package: str, activity: str, wait: bool=True, stop: bool=True) -&gt; bool|None:
        &#34;&#34;&#34;
        The function starts an Android app with the specified package and activity, optionally waiting
        for the launch to complete and stopping the app before starting the activity.
        
        Args:
            package (str): The package parameter is a string that represents the package name of the
                Android application you want to start. This is typically the unique identifier for the app and
                is specified in the AndroidManifest.xml file of the app.
            activity (str): The &#34;activity&#34; parameter refers to the specific activity or screen within the
                Android app that you want to start. An activity represents a single screen with a user
                interface, and it is the basic building block of an Android app. Each activity has a unique name
                that is specified in the AndroidManifest.xml file
            wait (bool): The &#34;wait&#34; parameter is a boolean value that determines whether the command
                should wait for the launch to complete before returning. If set to True, the command will wait
                for the launch to complete. If set to False, the command will not wait and will return
                immediately after starting the activity. Defaults to True
            stop (bool): The &#34;stop&#34; parameter is a boolean value that determines whether to force stop the
                target app before starting the activity. If it is set to True, the target app will be stopped
                before starting the activity. If it is set to False, the target app will not be stopped.
                Defaults to True
        
        Returns:
            Boolean indicates if app starting process is successful. `None` if no device found.
        &#34;&#34;&#34;
        if self.__selected_device is None:
            return
        # check if app is installed
        if not self.is_installed(package):
            return False
        self.send_keyevent_input(KeyCodes.KEYCODE_HOME)
        command = &#39;am start &#39;
        # wait for launch to complete
        if wait:
            command += &#39;-W &#39;
        if stop: # force stop the target app before starting the activity
            command += &#39;-S &#39;
        command += f&#39;{package}/{activity}&#39;
        Logger.info(f&#39;Starting app: [bold green]{package}[/bold green] ..&#39;)
        result = self.execute_shell_command(command)
        if &#39;Error&#39; in result:
            Logger.error(f&#39;Starting app [bold blue]{package}[/bold blue] failed&#39;)
            return False
        else:
            Logger.success(f&#39;App: [bold blue]{package}[/bold blue] started successfully&#39;)
            return True



    def stop_app(self, package: str) -&gt; bool|None:
        &#34;&#34;&#34;
        The function stops an Android app with the specified package.
        
        Args:
            package (str): The package parameter is a string that represents the package name of the app
                you want to stop.
        
        Returns:
            Boolean indicates if app stopping process is successful. `None` if no device found.
        &#34;&#34;&#34;
        if self.__selected_device is None:
            return
        Logger.info(f&#39;Stopping app: [bold green]{package}[/bold green] ..&#39;)
        result =  self.execute_shell_command(f&#39;am force-stop {package}&#39;)
        if &#39;Error&#39; in result:
            Logger.error(f&#39;Stopping app [bold blue]{package}[/bold blue] failed&#39;)
            return False
        else:
            Logger.success(f&#39;App: [bold blue]{package}[/bold blue] stopped successfully&#39;)
            return True



    def list_packages(self, package_type: str=&#39;all&#39;) -&gt; list|None:
        &#34;&#34;&#34;
        The function &#34;list_packages&#34; lists device android packages, you can also filter package type.
        
        Args:
            package_type (str): The `package_type` parameter is a string that specifies the type of
                packages to list. It has a default value of `all` that gets all packages on the device,
                but it can also take the following values: [all | enabled | disabled | system | third-party].
                Defaults to all
        
        Returns:
            List of packages. `None` if no device found.
        &#34;&#34;&#34;
        if self.__selected_device is None:
            return
        packages = []
        if self.__selected_device:
            package_type_flags = {&#39;all&#39;: &#39;&#39;, &#39;enabled&#39;: &#39;-e&#39;, &#39;disabled&#39;: &#39;-d&#39;, &#39;system&#39;: &#39;-s&#39;, &#39;third-party&#39;: &#39;-3&#39;}
            if package_type not in package_type_flags:
                package_type = &#39;all&#39;
            results = self.execute_shell_command(f&#39;pm list packages {package_type_flags[package_type]}&#39;).split(&#34;\n&#34;)
            packages = sorted([x.replace(&#39;package:&#39;, &#39;&#39;) for x in results])
            Logger.info(f&#39;There are [bold green]{len(packages)}[/bold green] [bold blue]{package_type}[/bold blue] packages&#39;)
            if self.__verbose:
                for package in packages:
                    Logger.print(f&#39;[bold green]{package}[/bold green]&#39;)
        return packages
    
    
    
    def get_package_activities(self, package: str) -&gt; list|None:
        &#34;&#34;&#34;
        The function `get_package_activities` retrieves the activities associated with a given package
        in order to start the app. this is useful to be able to start the app
        
        Args:
            package (str): The &#34;package&#34; parameter is a string that represents the name of the package for
                which you want to retrieve the activities.
        
        Returns:
            List of package activities. `None` if no device found.
        &#34;&#34;&#34;
        if self.__selected_device is None:
            return
        results = self.execute_shell_command(f&#39;dumpsys package {package}&#39;).split()
        activities = []
        for res in results:
            if f&#39;{package}/&#39; in res:
                activity = res.replace(&#39;&#34;&#39;, &#39;&#39;).replace(&#39;:&#39;, &#39;&#39;).replace(&#39;}&#39;, &#39;&#39;).strip()
                activities.append(activity)
                if self.__verbose:
                    Logger.print(f&#39;[bold green]{activity}[/bold green]&#39;)
        unique_activities = []
        for activity in activities:
            if activity not in unique_activities and activity.startswith(package):
                unique_activities.append(activity) 
        Logger.info(f&#39;There are [bold green]{len(unique_activities)}[/bold green] activities for package: {package}&#39;)
        return unique_activities



    # ------------------------------[ Device related Commands ]------------------------------



    def reboot(self, mode: str|None=None) -&gt; bool|None:
        &#34;&#34;&#34;
        The function `reboot` reboots the device with the specified mode, or with no mode if none is
        provided.
        
        Args:
            mode (str|None): The `mode` parameter is a string that specifies the type of reboot to
                perform. It can have one of the following values: [bootloader | recovery | sideload | sideload-auto-reboot]
        
        Returns:
            Boolean indicates if tv is rebooted successfully. `None` if no device found.
        &#34;&#34;&#34;
        if self.__selected_device is None:
            return
        command = &#39;reboot &#39;
        if mode:
            command += mode
        Logger.info(f&#39;Rebooting TV&#39; + f&#39; in mode [bold green]{mode}[bold green]&#39; if mode else &#39;&#39; + &#39; ..&#39;)
        result =  self.__execute_command(command)
        if &#39;error&#39; in result:
            Logger.error(f&#39;Rebooting failed&#39;)
            return False
        else:
            Logger.success(f&#39;Rebooted successfully&#39;)
            return True
    
    
    
    def execute_shell_command(self, command: str) -&gt; str:
        &#34;&#34;&#34;
        The function executes an adb shell command by calling `adb shell` command.
        
        Args:
            command (str): The `command` parameter is a string that represents the shell command that you
                want to execute.
        
        Returns:
            String of the output results of executing the shell command.
        &#34;&#34;&#34;
        return self.__execute_command(f&#39;shell {command}&#39;)



    # ------------------------------[ Inputs Commands ]------------------------------



    def send_keyevent_input(self, keycode: KeyCodes, long_press: bool=False):
        &#34;&#34;&#34;
        The function executes an adb shell command to send key event input that simulates pressing button keys.
        
        Args:
            keycode (KeyCode): the keycode to send, table of key codes: https://www.temblast.com/ref/akeyscode.htm
            long_press (bool): specify if simulate a long press for the key or not. Defaults to False.
        &#34;&#34;&#34;
        if self.__selected_device is None:
            return
        command = f&#39;input keyevent {keycode.name}&#39;
        if long_press:
            command += &#39; --longpress&#39;
        self.execute_shell_command(command)
    
    
    
    def send_text_input(self, text: str, encode_spaces: bool=True):
        &#34;&#34;&#34;
        The function executes an adb shell command to send text input.
        
        Args:
            text (str): the text string to send.
            encode_spaces (bool): specify if spaces should be replaced by `%s` or not. Defaults to True.
        &#34;&#34;&#34;
        if self.__selected_device is None:
            return
        processed_text = text.replace(&#39; &#39;, &#39;%s&#39;) if encode_spaces else text
        self.execute_shell_command(f&#39;input text {processed_text}&#39;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="AndroidTVController.android_tv_rc.adb_client.ADBClient.clean"><code class="name flex">
<span>def <span class="ident">clean</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Resets and clean</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clean(self):
    &#34;&#34;&#34;Resets and clean&#34;&#34;&#34;
    Logger.info(&#39;Cleaning up&#39;)
    self.__devices = []
    self.__selected_device = None
    self.__server_process = None</code></pre>
</details>
</dd>
<dt id="AndroidTVController.android_tv_rc.adb_client.ADBClient.connect"><code class="name flex">
<span>def <span class="ident">connect</span></span>(<span>self, ip: str) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>The function connects to an IP address and raises an error if the connection fails.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ip</code></strong> :&ensp;<code>str</code></dt>
<dd>The <code>ip</code> parameter in the <code>connect</code> method is a string that represents the IP
address of the device you want to connect.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Boolean</code></dt>
<dd>True if the connection succeeded, False if the connection failed.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def connect(self, ip: str) -&gt; bool:
    &#34;&#34;&#34;
    The function connects to an IP address and raises an error if the connection fails.
    
    Args:
        ip (str): The `ip` parameter in the `connect` method is a string that represents the IP
            address of the device you want to connect.
    
    Returns:
        Boolean: True if the connection succeeded, False if the connection failed.
    &#34;&#34;&#34;
    Logger.info(f&#39;Connecting to [bold green]{ip}[/bold green] ..&#39;)
    result = self.__execute_command(f&#39;connect {ip}&#39;, include_selected_serial=False)
    if &#34;connected&#34; in result:
        self.__devices = self.get_devices()
        self.__selected_device = self.__devices[-1]
        Logger.success(f&#39;Device: [bold blue]{self.__selected_device}[/bold blue] is connected successfully&#39;)
        return True
    else: # &#34;failed&#34; in result
        Logger.error(f&#39;Connection with [bold blue]{ip}[/bold blue] failed&#39;)
        return False</code></pre>
</details>
</dd>
<dt id="AndroidTVController.android_tv_rc.adb_client.ADBClient.disconnect"><code class="name flex">
<span>def <span class="ident">disconnect</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Disconnect selected device.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Boolean</code></dt>
<dd>True if the device is disconnected.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disconnect(self) -&gt; bool:
    &#34;&#34;&#34;
    Disconnect selected device.
    
    Returns:
        Boolean: True if the device is disconnected.
    &#34;&#34;&#34;
    Logger.info(f&#39;Disconnecting device..&#39;)
    if &#39;disconnected&#39; in self.__execute_command(&#39;disconnect&#39;):
        self.__devices = self.get_devices()
        self.__selected_device = None
        Logger.success(f&#39;Device: [bold blue]{self.__selected_device}[/bold blue] is disconnected&#39;)
        return True
    else:
        Logger.error(f&#39;Error while disconnecting device: [bold blue]{self.__selected_device}[/bold blue]&#39;)
        return False</code></pre>
</details>
</dd>
<dt id="AndroidTVController.android_tv_rc.adb_client.ADBClient.execute_shell_command"><code class="name flex">
<span>def <span class="ident">execute_shell_command</span></span>(<span>self, command: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>The function executes an adb shell command by calling <code>adb shell</code> command.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>command</code></strong> :&ensp;<code>str</code></dt>
<dd>The <code>command</code> parameter is a string that represents the shell command that you
want to execute.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>String of the output results of executing the shell command.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def execute_shell_command(self, command: str) -&gt; str:
    &#34;&#34;&#34;
    The function executes an adb shell command by calling `adb shell` command.
    
    Args:
        command (str): The `command` parameter is a string that represents the shell command that you
            want to execute.
    
    Returns:
        String of the output results of executing the shell command.
    &#34;&#34;&#34;
    return self.__execute_command(f&#39;shell {command}&#39;)</code></pre>
</details>
</dd>
<dt id="AndroidTVController.android_tv_rc.adb_client.ADBClient.get_device_info"><code class="name flex">
<span>def <span class="ident">get_device_info</span></span>(<span>self) ‑> dict | None</span>
</code></dt>
<dd>
<div class="desc"><p>The function <code>get_device_info</code> retrieves device information.</p>
<h2 id="returns">Returns</h2>
<p>Dictionary containing device information. <code>None</code> if no device found.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_device_info(self) -&gt; dict|None:
    &#34;&#34;&#34;
    The function `get_device_info` retrieves device information.
    
    Returns:
        Dictionary containing device information. `None` if no device found.
    &#34;&#34;&#34;
    if self.__selected_device is None:
        return
    device_info = {}
    results = self.execute_shell_command(&#39;getprop&#39;).split(&#39;\n&#39;)
    for data in results:
        match = re.match(r&#34;\[([^:]+)\]: \[([^:]+)\]&#34;, data)
        if match:
            prop = match.group(1)
            value = match.group(2)
            device_info[prop] = value
            if self.__verbose:
                Logger.print(f&#39;[bold green]{prop}[/bold green]: [yellow]{value}[/yellow]&#39;)
    return device_info</code></pre>
</details>
</dd>
<dt id="AndroidTVController.android_tv_rc.adb_client.ADBClient.get_devices"><code class="name flex">
<span>def <span class="ident">get_devices</span></span>(<span>self, include_descriptions: bool = True) ‑> list</span>
</code></dt>
<dd>
<div class="desc"><p>The function <code>get_devices</code> retrieves a list of connected devices, including their IP address,
serial number, state, and optional descriptions.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>include_descriptions</code></strong> :&ensp;<code>bool</code></dt>
<dd>The <code>include_descriptions</code> parameter is a boolean flag that
determines whether or not to include descriptions for the connected devices. If set to <code>True</code>,
the descriptions will be included in the returned list of devices. If set to <code>False</code>, the
descriptions will be excluded. Defaults to True</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt>The method <code>get_devices</code> returns a list of dictionaries, where each dictionary represents a</dt>
<dt><code>connected device. Each dictionary contains the following keys</code></dt>
<dd>'ip', 'serial_number', 'state',</dd>
</dl>
<p>and 'description'.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_devices(self, include_descriptions: bool=True) -&gt; list:
    &#34;&#34;&#34;
    The function `get_devices` retrieves a list of connected devices, including their IP address,
    serial number, state, and optional descriptions.
    
    Args:
        include_descriptions (bool): The `include_descriptions` parameter is a boolean flag that
            determines whether or not to include descriptions for the connected devices. If set to `True`,
            the descriptions will be included in the returned list of devices. If set to `False`, the
            descriptions will be excluded. Defaults to True

    Returns:
        The method `get_devices` returns a list of dictionaries, where each dictionary represents a
        connected device. Each dictionary contains the following keys: &#39;ip&#39;, &#39;serial_number&#39;, &#39;state&#39;,
        and &#39;description&#39;.
    &#34;&#34;&#34;
    Logger.info(f&#39;Getting connected devices..&#39;)
    self.__devices = []
    command = &#39;devices&#39;
    if include_descriptions:
        command += &#39; -l&#39;
    result = self.__execute_command(command, include_selected_serial=False)
    devices = result.split(&#34;\n&#34;)[1:]
    Logger.info(f&#39;There are [bold green]{len(devices)}[/bold green] connected devices&#39;)
    for i, device in enumerate(devices):
        data = device.split()
        serial_number = data[0]
        self.__devices.append(serial_number)
        if self.__verbose:
            Logger.print(f&#39;[bold green]Device[/bold green] ({i+1}): [yellow]{serial_number}[/yellow]&#39;)
    return self.__devices</code></pre>
</details>
</dd>
<dt id="AndroidTVController.android_tv_rc.adb_client.ADBClient.get_devpath"><code class="name flex">
<span>def <span class="ident">get_devpath</span></span>(<span>self) ‑> str | None</span>
</code></dt>
<dd>
<div class="desc"><p>The function <code>get_devpath</code> retrieves the device path of a connected Android device'.</p>
<h2 id="returns">Returns</h2>
<p>String represents the device path, for example usb:1-4.3 for usb connected device. <code>None</code> if no device found.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_devpath(self) -&gt; str|None:
    &#34;&#34;&#34;
    The function `get_devpath` retrieves the device path of a connected Android device&#39;.
    
    Returns:
        String represents the device path, for example usb:1-4.3 for usb connected device. `None` if no device found.
    &#34;&#34;&#34;
    if self.__selected_device is None:
        return
    device_devpath = self.__execute_command(&#39;get-devpath&#39;)
    Logger.info(f&#39;Device dev_path: {device_devpath}&#39;)
    return device_devpath</code></pre>
</details>
</dd>
<dt id="AndroidTVController.android_tv_rc.adb_client.ADBClient.get_ip_address"><code class="name flex">
<span>def <span class="ident">get_ip_address</span></span>(<span>self, interface: str = 'wlan0') ‑> str | None</span>
</code></dt>
<dd>
<div class="desc"><p>The function <code>get_ip_address</code> returns the device IP address of a specified network interface.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>interface</code></strong> :&ensp;<code>str</code></dt>
<dd>The <code>interface</code> parameter is a string that specifies the network interface to
retrieve the IP address from. In this case, the default value is set to "wlan0", which is a
common interface name for wireless LAN connections on Linux-based systems. Defaults to wlan0</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The IP address of the selected device. <code>None</code> if no device found.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_ip_address(self, interface: str=&#39;wlan0&#39;) -&gt; str|None:
    &#34;&#34;&#34;
    The function `get_ip_address` returns the device IP address of a specified network interface.
    
    Args:
        interface (str): The `interface` parameter is a string that specifies the network interface to
            retrieve the IP address from. In this case, the default value is set to &#34;wlan0&#34;, which is a
            common interface name for wireless LAN connections on Linux-based systems. Defaults to wlan0
    
    Returns:
        The IP address of the selected device. `None` if no device found.
    &#34;&#34;&#34;
    if self.__selected_device is None:
        return
    device_ip = &#39;&#39;
    if result := self.execute_shell_command(f&#39;ifconfig {interface}&#39;):
        if match_obj := re.search(r&#34;inet addr:(.+)  Bcast&#34;, result, re.M | re.I):
            device_ip = match_obj[1]
            Logger.info(f&#39;Device ip: {device_ip}&#39;)
    return device_ip</code></pre>
</details>
</dd>
<dt id="AndroidTVController.android_tv_rc.adb_client.ADBClient.get_package_activities"><code class="name flex">
<span>def <span class="ident">get_package_activities</span></span>(<span>self, package: str) ‑> list | None</span>
</code></dt>
<dd>
<div class="desc"><p>The function <code>get_package_activities</code> retrieves the activities associated with a given package
in order to start the app. this is useful to be able to start the app</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>package</code></strong> :&ensp;<code>str</code></dt>
<dd>The "package" parameter is a string that represents the name of the package for
which you want to retrieve the activities.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>List of package activities. <code>None</code> if no device found.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_package_activities(self, package: str) -&gt; list|None:
    &#34;&#34;&#34;
    The function `get_package_activities` retrieves the activities associated with a given package
    in order to start the app. this is useful to be able to start the app
    
    Args:
        package (str): The &#34;package&#34; parameter is a string that represents the name of the package for
            which you want to retrieve the activities.
    
    Returns:
        List of package activities. `None` if no device found.
    &#34;&#34;&#34;
    if self.__selected_device is None:
        return
    results = self.execute_shell_command(f&#39;dumpsys package {package}&#39;).split()
    activities = []
    for res in results:
        if f&#39;{package}/&#39; in res:
            activity = res.replace(&#39;&#34;&#39;, &#39;&#39;).replace(&#39;:&#39;, &#39;&#39;).replace(&#39;}&#39;, &#39;&#39;).strip()
            activities.append(activity)
            if self.__verbose:
                Logger.print(f&#39;[bold green]{activity}[/bold green]&#39;)
    unique_activities = []
    for activity in activities:
        if activity not in unique_activities and activity.startswith(package):
            unique_activities.append(activity) 
    Logger.info(f&#39;There are [bold green]{len(unique_activities)}[/bold green] activities for package: {package}&#39;)
    return unique_activities</code></pre>
</details>
</dd>
<dt id="AndroidTVController.android_tv_rc.adb_client.ADBClient.get_selected_device"><code class="name flex">
<span>def <span class="ident">get_selected_device</span></span>(<span>self) ‑> str | None</span>
</code></dt>
<dd>
<div class="desc"><p>Get current selected device.</p>
<h2 id="returns">Returns</h2>
<p>Selected device serial number. <code>None</code> if no device found.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_selected_device(self) -&gt; str|None:
    &#34;&#34;&#34;
    Get current selected device.
    
    Returns:
        Selected device serial number. `None` if no device found.
    &#34;&#34;&#34;
    if self.__selected_device:
        Logger.success(f&#39;Selected device: [bold blue]{self.__selected_device}[/bold blue]&#39;)
    else:
        Logger.error(f&#39;No device found&#39;)
    return self.__selected_device</code></pre>
</details>
</dd>
<dt id="AndroidTVController.android_tv_rc.adb_client.ADBClient.get_serialno"><code class="name flex">
<span>def <span class="ident">get_serialno</span></span>(<span>self) ‑> str | None</span>
</code></dt>
<dd>
<div class="desc"><p>The function <code>get_serialno</code> returns the serial number of a selected device.</p>
<h2 id="returns">Returns</h2>
<p>String represents device serial number of the selected device. <code>None</code> if no device found.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_serialno(self) -&gt; str|None:
    &#34;&#34;&#34;
    The function `get_serialno` returns the serial number of a selected device.
    
    Returns:
        String represents device serial number of the selected device. `None` if no device found.
    &#34;&#34;&#34;
    if self.__selected_device is None:
        return
    device_serialno = self.__execute_command(&#39;get-serialno&#39;)
    Logger.info(f&#39;Device Serial number: {device_serialno}&#39;)
    return device_serialno</code></pre>
</details>
</dd>
<dt id="AndroidTVController.android_tv_rc.adb_client.ADBClient.get_state"><code class="name flex">
<span>def <span class="ident">get_state</span></span>(<span>self) ‑> str | None</span>
</code></dt>
<dd>
<div class="desc"><p>The function <code>get_state</code> returns the state of connected device.</p>
<h2 id="returns">Returns</h2>
<p>String represents device state. <code>None</code> if no device found.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_state(self) -&gt; str|None:
    &#34;&#34;&#34;
    The function `get_state` returns the state of connected device.
    
    Returns:
        String represents device state. `None` if no device found.
    &#34;&#34;&#34;
    if self.__selected_device is None:
        return
    device_state = self.__execute_command(&#39;get-state&#39;)
    Logger.info(f&#39;Device: ({self.__selected_device}) state is {device_state}&#39;)
    return device_state</code></pre>
</details>
</dd>
<dt id="AndroidTVController.android_tv_rc.adb_client.ADBClient.install"><code class="name flex">
<span>def <span class="ident">install</span></span>(<span>self, apk_file: str, replace: bool = True) ‑> bool | None</span>
</code></dt>
<dd>
<div class="desc"><p>The function installs an APK file on a device, with an option to replace/update an existing
installation.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>apk_file</code></strong> :&ensp;<code>str</code></dt>
<dd>The <code>apk_file</code> parameter is a string that represents the file path of the APK
file that you want to install.</dd>
<dt><strong><code>replace</code></strong> :&ensp;<code>bool</code></dt>
<dd>The <code>replace</code> parameter is a boolean value that determines whether to replace
an existing installation of the APK file. If <code>replace</code> is set to <code>True</code>, the existing
installation will be replaced. If <code>replace</code> is set to <code>False</code>, the existing installation will
not be replaced and an error will. Defaults to True</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Boolean indicates if installation process is successful. <code>None</code> if no device found.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def install(self, apk_file: str, replace: bool=True) -&gt; bool|None:
    &#34;&#34;&#34;
    The function installs an APK file on a device, with an option to replace/update an existing
    installation.
    
    Args:
        apk_file (str): The `apk_file` parameter is a string that represents the file path of the APK
            file that you want to install.
        replace (bool): The `replace` parameter is a boolean value that determines whether to replace
            an existing installation of the APK file. If `replace` is set to `True`, the existing
            installation will be replaced. If `replace` is set to `False`, the existing installation will
            not be replaced and an error will. Defaults to True
    
    Returns:
        Boolean indicates if installation process is successful. `None` if no device found.
    &#34;&#34;&#34;
    if self.__selected_device is None:
        return
    command = &#39;install &#39;
    if replace:
        command += &#39;-r &#39;
    command += apk_file
    Logger.info(f&#39;Installing APK file [bold green]{apk_file}[/bold green], it will took up to 2 minutes to complete..&#39;)
    result = self.__execute_command(command)
    if &#39;Success&#39; in result:
        Logger.success(f&#39;APK [bold blue]{apk_file}[/bold blue] is installed successfully&#39;)
        return True
    else:
        Logger.error(f&#39;Installation process failed&#39;)
        return False</code></pre>
</details>
</dd>
<dt id="AndroidTVController.android_tv_rc.adb_client.ADBClient.is_connected"><code class="name flex">
<span>def <span class="ident">is_connected</span></span>(<span>self, ip: str) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>The function checks if a device with a given IP address is connected to adb server.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ip</code></strong> :&ensp;<code>str</code></dt>
<dd>The <code>ip</code> parameter is a string that represents an IP address.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Boolean value. It returns True if there is a device in the list of devices with the
specified IP address, and False otherwise.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_connected(self, ip: str) -&gt; bool:
    &#34;&#34;&#34;
    The function checks if a device with a given IP address is connected to adb server.
    
    Args:
        ip (str): The `ip` parameter is a string that represents an IP address.
    
    Returns:
        Boolean value. It returns True if there is a device in the list of devices with the
        specified IP address, and False otherwise.
    &#34;&#34;&#34;
    for device in self.__devices:
        if device.split(&#39;:&#39;)[0] == ip:
            Logger.success(f&#39;Device: [bold blue]{ip}[/bold blue] is connected&#39;)
            return True
    Logger.error(f&#39;Device [bold blue]{ip}[/bold blue] is not connected&#39;)
    return False</code></pre>
</details>
</dd>
<dt id="AndroidTVController.android_tv_rc.adb_client.ADBClient.is_installed"><code class="name flex">
<span>def <span class="ident">is_installed</span></span>(<span>self, package_name: str) ‑> bool | None</span>
</code></dt>
<dd>
<div class="desc"><p>The function checks if the specified package is installed or not.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>package_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the package, for example 'com.google.chrome'</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Boolean indicates if app is installed or not. <code>None</code> if no device found.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_installed(self, package_name: str) -&gt; bool|None:
    &#34;&#34;&#34;
    The function checks if the specified package is installed or not.
    
    Args:
        package_name (str): The name of the package, for example &#39;com.google.chrome&#39;
    
    Returns:
        Boolean indicates if app is installed or not. `None` if no device found.
    &#34;&#34;&#34;
    if self.__selected_device is None:
        return
    command = f&#39;pm list packages&#39;
    app_installed =  package_name in self.execute_shell_command(command)
    if app_installed:
        Logger.success(f&#39;App [bold blue]{package_name}[/bold blue] is installed&#39;)
        return True
    else:
        Logger.error(f&#39;App [bold blue]{package_name}[/bold blue] is not installed&#39;)
        return False</code></pre>
</details>
</dd>
<dt id="AndroidTVController.android_tv_rc.adb_client.ADBClient.kill_server"><code class="name flex">
<span>def <span class="ident">kill_server</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>The function <code>kill_server</code> stops the ADB server and terminates any running server process.</p>
<h2 id="returns">Returns</h2>
<p>Boolean indicating whether the server is stopped or not.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def kill_server(self) -&gt; bool:
    &#34;&#34;&#34;
    The function `kill_server` stops the ADB server and terminates any running server process.
            
    Returns:
        Boolean indicating whether the server is stopped or not.
    &#34;&#34;&#34;
    Logger.info(&#39;Stopping ADB server..&#39;)
    self.__execute_command(&#39;kill-server&#39;, include_selected_serial=False)
    if self.__server_process:
        self.__server_process.terminate()
        self.__server_process = None
        self.clean()
        Logger.success(&#39;ADB server is stopped&#39;)
        return True
    else:
        Logger.error(f&#39;No ADB server process running&#39;)
        return False</code></pre>
</details>
</dd>
<dt id="AndroidTVController.android_tv_rc.adb_client.ADBClient.list_packages"><code class="name flex">
<span>def <span class="ident">list_packages</span></span>(<span>self, package_type: str = 'all') ‑> list | None</span>
</code></dt>
<dd>
<div class="desc"><p>The function "list_packages" lists device android packages, you can also filter package type.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>package_type</code></strong> :&ensp;<code>str</code></dt>
<dd>The <code>package_type</code> parameter is a string that specifies the type of
packages to list. It has a default value of <code>all</code> that gets all packages on the device,
but it can also take the following values: [all | enabled | disabled | system | third-party].
Defaults to all</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>List of packages. <code>None</code> if no device found.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list_packages(self, package_type: str=&#39;all&#39;) -&gt; list|None:
    &#34;&#34;&#34;
    The function &#34;list_packages&#34; lists device android packages, you can also filter package type.
    
    Args:
        package_type (str): The `package_type` parameter is a string that specifies the type of
            packages to list. It has a default value of `all` that gets all packages on the device,
            but it can also take the following values: [all | enabled | disabled | system | third-party].
            Defaults to all
    
    Returns:
        List of packages. `None` if no device found.
    &#34;&#34;&#34;
    if self.__selected_device is None:
        return
    packages = []
    if self.__selected_device:
        package_type_flags = {&#39;all&#39;: &#39;&#39;, &#39;enabled&#39;: &#39;-e&#39;, &#39;disabled&#39;: &#39;-d&#39;, &#39;system&#39;: &#39;-s&#39;, &#39;third-party&#39;: &#39;-3&#39;}
        if package_type not in package_type_flags:
            package_type = &#39;all&#39;
        results = self.execute_shell_command(f&#39;pm list packages {package_type_flags[package_type]}&#39;).split(&#34;\n&#34;)
        packages = sorted([x.replace(&#39;package:&#39;, &#39;&#39;) for x in results])
        Logger.info(f&#39;There are [bold green]{len(packages)}[/bold green] [bold blue]{package_type}[/bold blue] packages&#39;)
        if self.__verbose:
            for package in packages:
                Logger.print(f&#39;[bold green]{package}[/bold green]&#39;)
    return packages</code></pre>
</details>
</dd>
<dt id="AndroidTVController.android_tv_rc.adb_client.ADBClient.pull"><code class="name flex">
<span>def <span class="ident">pull</span></span>(<span>self, remote: str, local: str, preserve_meta: bool = False) ‑> bool | None</span>
</code></dt>
<dd>
<div class="desc"><p>The function <code>pull</code> copies remote files and directories to a device, with an option to preserve
file metadata like time stamp and mode.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>remote</code></strong> :&ensp;<code>str</code></dt>
<dd>The <code>remote</code> parameter is a string that represents the path of the remote file
or directory that you want to copy to the device.</dd>
<dt><strong><code>local</code></strong> :&ensp;<code>str</code></dt>
<dd>The "local" parameter is a string that represents the local directory or file
path where the remote files and directories will be copied to.</dd>
<dt><strong><code>preserve_meta</code></strong> :&ensp;<code>bool</code></dt>
<dd>The <code>preserve_meta</code> parameter is a boolean flag that determines whether
to preserve the file time stamp and mode during the file transfer process. If <code>preserve_meta</code> is
set to <code>True</code>, the <code>-k</code> option will be added to the command, indicating that the file time stamp
and mode should be. Defaults to False</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Boolean indicating whether the download operation was successful. <code>None</code> if no device found.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pull(self, remote: str, local: str, preserve_meta: bool=False) -&gt; bool|None:
    &#34;&#34;&#34;
    The function `pull` copies remote files and directories to a device, with an option to preserve
    file metadata like time stamp and mode.
    
    Args:
        remote (str): The `remote` parameter is a string that represents the path of the remote file
            or directory that you want to copy to the device.
        local (str): The &#34;local&#34; parameter is a string that represents the local directory or file
            path where the remote files and directories will be copied to.
        preserve_meta (bool): The `preserve_meta` parameter is a boolean flag that determines whether
            to preserve the file time stamp and mode during the file transfer process. If `preserve_meta` is
            set to `True`, the `-k` option will be added to the command, indicating that the file time stamp
            and mode should be. Defaults to False
    
    Returns:
        Boolean indicating whether the download operation was successful. `None` if no device found.
    &#34;&#34;&#34;
    if self.__selected_device is None:
        return
    command = &#39;pull &#39;
    if preserve_meta:
        command += &#39;-k &#39;
    command += f&#39;{remote} {local}&#39;
    Logger.info(f&#39;Downloading: [bold green]{remote}[/bold green] to [bold green]{local}[/bold green] ..&#39;)
    result = self.__execute_command(command)
    if &#39;1 file pulled,&#39; in result:
        Logger.success(f&#39;File [bold blue]{remote}[/bold blue] downloaded to [bold blue]{local}[/bold blue] successfully&#39;)
        return True
    else:
        Logger.error(f&#39;Downloading [bold blue]{remote}[/bold blue] to [bold blue]{local}[/bold blue] failed&#39;)
        return False</code></pre>
</details>
</dd>
<dt id="AndroidTVController.android_tv_rc.adb_client.ADBClient.push"><code class="name flex">
<span>def <span class="ident">push</span></span>(<span>self, local: str, remote: str = '/data/local/tmp/') ‑> bool | None</span>
</code></dt>
<dd>
<div class="desc"><p>Copy files and directories from the local device (computer) to
a remote location on the device.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>local</code></strong> :&ensp;<code>str</code></dt>
<dd>The <code>local</code> parameter is a string that represents the path of the file or
directory on the local device (computer) that you want to copy to the remote location on the
device.</dd>
<dt><strong><code>remote</code></strong> :&ensp;<code>str</code></dt>
<dd>The <code>remote</code> parameter is a string that specifies the destination location on
the device where the files or directories from the local device will be copied to. By default,
the destination location is set to <code>/data/local/tmp/</code>, but you can provide a different path if
needed. Defaults to /data/local/tmp/</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Boolean indicating whether the upload operation was successful. <code>None</code> if no device found.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def push(self, local: str, remote: str=&#39;/data/local/tmp/&#39;) -&gt; bool|None:
    &#34;&#34;&#34;
    Copy files and directories from the local device (computer) to
    a remote location on the device.
    
    Args:
        local (str): The `local` parameter is a string that represents the path of the file or
            directory on the local device (computer) that you want to copy to the remote location on the
            device.
        remote (str): The `remote` parameter is a string that specifies the destination location on
            the device where the files or directories from the local device will be copied to. By default,
            the destination location is set to `/data/local/tmp/`, but you can provide a different path if
            needed. Defaults to /data/local/tmp/
    
    Returns:
        Boolean indicating whether the upload operation was successful. `None` if no device found.
    &#34;&#34;&#34;
    if self.__selected_device is None:
        return
    Logger.info(f&#39;Uploading: [bold green]{local}[/bold green] to [bold green]{remote}[/bold green] ..&#39;)
    result = self.__execute_command(f&#39;push {local} {remote}&#39;) 
    if &#39;1 file pushed&#39; in result:
        Logger.success(f&#39;File [bold blue]{local}[/bold blue] uploaded to [bold blue]{remote}[/bold blue] successfully&#39;)
        return True
    else:
        Logger.error(f&#39;Uploading [bold blue]{local}[/bold blue] to [bold blue]{remote}[/bold blue] failed&#39;)
        return False</code></pre>
</details>
</dd>
<dt id="AndroidTVController.android_tv_rc.adb_client.ADBClient.reboot"><code class="name flex">
<span>def <span class="ident">reboot</span></span>(<span>self, mode: str | None = None) ‑> bool | None</span>
</code></dt>
<dd>
<div class="desc"><p>The function <code>reboot</code> reboots the device with the specified mode, or with no mode if none is
provided.</p>
<h2 id="args">Args</h2>
<p>mode (str|None): The <code>mode</code> parameter is a string that specifies the type of reboot to
perform. It can have one of the following values: [bootloader | recovery | sideload | sideload-auto-reboot]</p>
<h2 id="returns">Returns</h2>
<p>Boolean indicates if tv is rebooted successfully. <code>None</code> if no device found.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reboot(self, mode: str|None=None) -&gt; bool|None:
    &#34;&#34;&#34;
    The function `reboot` reboots the device with the specified mode, or with no mode if none is
    provided.
    
    Args:
        mode (str|None): The `mode` parameter is a string that specifies the type of reboot to
            perform. It can have one of the following values: [bootloader | recovery | sideload | sideload-auto-reboot]
    
    Returns:
        Boolean indicates if tv is rebooted successfully. `None` if no device found.
    &#34;&#34;&#34;
    if self.__selected_device is None:
        return
    command = &#39;reboot &#39;
    if mode:
        command += mode
    Logger.info(f&#39;Rebooting TV&#39; + f&#39; in mode [bold green]{mode}[bold green]&#39; if mode else &#39;&#39; + &#39; ..&#39;)
    result =  self.__execute_command(command)
    if &#39;error&#39; in result:
        Logger.error(f&#39;Rebooting failed&#39;)
        return False
    else:
        Logger.success(f&#39;Rebooted successfully&#39;)
        return True</code></pre>
</details>
</dd>
<dt id="AndroidTVController.android_tv_rc.adb_client.ADBClient.select_device"><code class="name flex">
<span>def <span class="ident">select_device</span></span>(<span>self, device_serial: str) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>The function selects a device based on its serial number.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>device_serial</code></strong> :&ensp;<code>str</code></dt>
<dd>The <code>device_serial</code> parameter is a string that represents the serial
number of a device.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Boolean</code></dt>
<dd>True if the device is found and selected.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def select_device(self, device_serial: str) -&gt; bool:
    &#34;&#34;&#34;
    The function selects a device based on its serial number.
    
    Args:
        device_serial (str): The `device_serial` parameter is a string that represents the serial
            number of a device.
    
    Returns:
        Boolean: True if the device is found and selected.
    &#34;&#34;&#34;
    if device_serial in self.__devices:
        self.__selected_device = device_serial
        Logger.success(f&#39;Selected device: [bold blue]{self.__selected_device}[/bold blue]&#39;)
        return True
    else:
        Logger.error(f&#39;Device: [bold blue]{device_serial}[/bold blue] is not found&#39;)
        return False</code></pre>
</details>
</dd>
<dt id="AndroidTVController.android_tv_rc.adb_client.ADBClient.send_keyevent_input"><code class="name flex">
<span>def <span class="ident">send_keyevent_input</span></span>(<span>self, keycode: <a title="AndroidTVController.android_tv_rc.key_codes.KeyCodes" href="key_codes.html#AndroidTVController.android_tv_rc.key_codes.KeyCodes">KeyCodes</a>, long_press: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>The function executes an adb shell command to send key event input that simulates pressing button keys.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>keycode</code></strong> :&ensp;<code>KeyCode</code></dt>
<dd>the keycode to send, table of key codes: <a href="https://www.temblast.com/ref/akeyscode.htm">https://www.temblast.com/ref/akeyscode.htm</a></dd>
<dt><strong><code>long_press</code></strong> :&ensp;<code>bool</code></dt>
<dd>specify if simulate a long press for the key or not. Defaults to False.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_keyevent_input(self, keycode: KeyCodes, long_press: bool=False):
    &#34;&#34;&#34;
    The function executes an adb shell command to send key event input that simulates pressing button keys.
    
    Args:
        keycode (KeyCode): the keycode to send, table of key codes: https://www.temblast.com/ref/akeyscode.htm
        long_press (bool): specify if simulate a long press for the key or not. Defaults to False.
    &#34;&#34;&#34;
    if self.__selected_device is None:
        return
    command = f&#39;input keyevent {keycode.name}&#39;
    if long_press:
        command += &#39; --longpress&#39;
    self.execute_shell_command(command)</code></pre>
</details>
</dd>
<dt id="AndroidTVController.android_tv_rc.adb_client.ADBClient.send_text_input"><code class="name flex">
<span>def <span class="ident">send_text_input</span></span>(<span>self, text: str, encode_spaces: bool = True)</span>
</code></dt>
<dd>
<div class="desc"><p>The function executes an adb shell command to send text input.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>text</code></strong> :&ensp;<code>str</code></dt>
<dd>the text string to send.</dd>
<dt><strong><code>encode_spaces</code></strong> :&ensp;<code>bool</code></dt>
<dd>specify if spaces should be replaced by <code>%s</code> or not. Defaults to True.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_text_input(self, text: str, encode_spaces: bool=True):
    &#34;&#34;&#34;
    The function executes an adb shell command to send text input.
    
    Args:
        text (str): the text string to send.
        encode_spaces (bool): specify if spaces should be replaced by `%s` or not. Defaults to True.
    &#34;&#34;&#34;
    if self.__selected_device is None:
        return
    processed_text = text.replace(&#39; &#39;, &#39;%s&#39;) if encode_spaces else text
    self.execute_shell_command(f&#39;input text {processed_text}&#39;)</code></pre>
</details>
</dd>
<dt id="AndroidTVController.android_tv_rc.adb_client.ADBClient.start_app"><code class="name flex">
<span>def <span class="ident">start_app</span></span>(<span>self, package: str, activity: str, wait: bool = True, stop: bool = True) ‑> bool | None</span>
</code></dt>
<dd>
<div class="desc"><p>The function starts an Android app with the specified package and activity, optionally waiting
for the launch to complete and stopping the app before starting the activity.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>package</code></strong> :&ensp;<code>str</code></dt>
<dd>The package parameter is a string that represents the package name of the
Android application you want to start. This is typically the unique identifier for the app and
is specified in the AndroidManifest.xml file of the app.</dd>
<dt><strong><code>activity</code></strong> :&ensp;<code>str</code></dt>
<dd>The "activity" parameter refers to the specific activity or screen within the
Android app that you want to start. An activity represents a single screen with a user
interface, and it is the basic building block of an Android app. Each activity has a unique name
that is specified in the AndroidManifest.xml file</dd>
<dt><strong><code>wait</code></strong> :&ensp;<code>bool</code></dt>
<dd>The "wait" parameter is a boolean value that determines whether the command
should wait for the launch to complete before returning. If set to True, the command will wait
for the launch to complete. If set to False, the command will not wait and will return
immediately after starting the activity. Defaults to True</dd>
<dt><strong><code>stop</code></strong> :&ensp;<code>bool</code></dt>
<dd>The "stop" parameter is a boolean value that determines whether to force stop the
target app before starting the activity. If it is set to True, the target app will be stopped
before starting the activity. If it is set to False, the target app will not be stopped.
Defaults to True</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Boolean indicates if app starting process is successful. <code>None</code> if no device found.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start_app(self, package: str, activity: str, wait: bool=True, stop: bool=True) -&gt; bool|None:
    &#34;&#34;&#34;
    The function starts an Android app with the specified package and activity, optionally waiting
    for the launch to complete and stopping the app before starting the activity.
    
    Args:
        package (str): The package parameter is a string that represents the package name of the
            Android application you want to start. This is typically the unique identifier for the app and
            is specified in the AndroidManifest.xml file of the app.
        activity (str): The &#34;activity&#34; parameter refers to the specific activity or screen within the
            Android app that you want to start. An activity represents a single screen with a user
            interface, and it is the basic building block of an Android app. Each activity has a unique name
            that is specified in the AndroidManifest.xml file
        wait (bool): The &#34;wait&#34; parameter is a boolean value that determines whether the command
            should wait for the launch to complete before returning. If set to True, the command will wait
            for the launch to complete. If set to False, the command will not wait and will return
            immediately after starting the activity. Defaults to True
        stop (bool): The &#34;stop&#34; parameter is a boolean value that determines whether to force stop the
            target app before starting the activity. If it is set to True, the target app will be stopped
            before starting the activity. If it is set to False, the target app will not be stopped.
            Defaults to True
    
    Returns:
        Boolean indicates if app starting process is successful. `None` if no device found.
    &#34;&#34;&#34;
    if self.__selected_device is None:
        return
    # check if app is installed
    if not self.is_installed(package):
        return False
    self.send_keyevent_input(KeyCodes.KEYCODE_HOME)
    command = &#39;am start &#39;
    # wait for launch to complete
    if wait:
        command += &#39;-W &#39;
    if stop: # force stop the target app before starting the activity
        command += &#39;-S &#39;
    command += f&#39;{package}/{activity}&#39;
    Logger.info(f&#39;Starting app: [bold green]{package}[/bold green] ..&#39;)
    result = self.execute_shell_command(command)
    if &#39;Error&#39; in result:
        Logger.error(f&#39;Starting app [bold blue]{package}[/bold blue] failed&#39;)
        return False
    else:
        Logger.success(f&#39;App: [bold blue]{package}[/bold blue] started successfully&#39;)
        return True</code></pre>
</details>
</dd>
<dt id="AndroidTVController.android_tv_rc.adb_client.ADBClient.start_server"><code class="name flex">
<span>def <span class="ident">start_server</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>The function <code>start_server</code> starts an ADB server and waits for it to start up.</p>
<h2 id="returns">Returns</h2>
<p>Boolean indicating whether the server is running or not.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start_server(self) -&gt; bool:
    &#34;&#34;&#34;
    The function `start_server` starts an ADB server and waits for it to start up.
    
    Returns:
        Boolean indicating whether the server is running or not.
    &#34;&#34;&#34;
    Logger.info(&#39;Starting ADB server..&#39;)
    
    # start the adb server as background process
    self.__server_process = self.__execute_command(&#39;start-server&#39;, blocking=False, include_selected_serial=False)
    
    # give time to start up
    time.sleep(5)
    
    if self.__server_process:
        Logger.success(&#39;ADB server is started&#39;)
        return True
    else:
        Logger.error(f&#39;Unable to start ADB server&#39;)
        return False</code></pre>
</details>
</dd>
<dt id="AndroidTVController.android_tv_rc.adb_client.ADBClient.stop_app"><code class="name flex">
<span>def <span class="ident">stop_app</span></span>(<span>self, package: str) ‑> bool | None</span>
</code></dt>
<dd>
<div class="desc"><p>The function stops an Android app with the specified package.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>package</code></strong> :&ensp;<code>str</code></dt>
<dd>The package parameter is a string that represents the package name of the app
you want to stop.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Boolean indicates if app stopping process is successful. <code>None</code> if no device found.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop_app(self, package: str) -&gt; bool|None:
    &#34;&#34;&#34;
    The function stops an Android app with the specified package.
    
    Args:
        package (str): The package parameter is a string that represents the package name of the app
            you want to stop.
    
    Returns:
        Boolean indicates if app stopping process is successful. `None` if no device found.
    &#34;&#34;&#34;
    if self.__selected_device is None:
        return
    Logger.info(f&#39;Stopping app: [bold green]{package}[/bold green] ..&#39;)
    result =  self.execute_shell_command(f&#39;am force-stop {package}&#39;)
    if &#39;Error&#39; in result:
        Logger.error(f&#39;Stopping app [bold blue]{package}[/bold blue] failed&#39;)
        return False
    else:
        Logger.success(f&#39;App: [bold blue]{package}[/bold blue] stopped successfully&#39;)
        return True</code></pre>
</details>
</dd>
<dt id="AndroidTVController.android_tv_rc.adb_client.ADBClient.uninstall"><code class="name flex">
<span>def <span class="ident">uninstall</span></span>(<span>self, package: str, keep_data: bool = False) ‑> bool | None</span>
</code></dt>
<dd>
<div class="desc"><p>The <code>uninstall</code> function removes an app package from a device, with an option to keep the data
and cache directories.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>package</code></strong> :&ensp;<code>str</code></dt>
<dd>The package parameter is a string that represents the app package name that you
want to uninstall from the device.</dd>
<dt><strong><code>keep_data</code></strong> :&ensp;<code>bool</code></dt>
<dd>A boolean parameter that determines whether to keep the data and cache
directories of the app package when uninstalling. If set to True, the directories will be kept.
If set to False (default), the directories will be removed along with the app package. Defaults
to False</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Boolean indicates if uninstallation process is successful. <code>None</code> if no device found.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def uninstall(self, package: str, keep_data: bool=False) -&gt; bool|None:
    &#34;&#34;&#34;
    The `uninstall` function removes an app package from a device, with an option to keep the data
    and cache directories.
    
    Args:
        package (str): The package parameter is a string that represents the app package name that you
            want to uninstall from the device.
        keep_data (bool): A boolean parameter that determines whether to keep the data and cache
            directories of the app package when uninstalling. If set to True, the directories will be kept.
            If set to False (default), the directories will be removed along with the app package. Defaults
            to False
    
    Returns:
        Boolean indicates if uninstallation process is successful. `None` if no device found.
    &#34;&#34;&#34;
    if self.__selected_device is None:
        return
    command = &#39;uninstall &#39;
    if keep_data:
        command += &#39;-k &#39;
    command += package
    message = f&#39;Uninstalling package [bold green]{package}[/bold green]&#39;
    message += &#39;while keeping the data&#39; if keep_data else &#39;&#39;
    message += &#39;, it will took up to 2 minutes to complete..&#39;
    Logger.info(message)
    result = self.__execute_command(command)
    if &#39;Success&#39; in result:
        Logger.success(f&#39;Package [bold blue]{package}[/bold blue] is uninstalled successfully&#39;)
        return True
    else:
        Logger.error(f&#39;Uninstallation process failed&#39;)
        return False</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="AndroidTVController.android_tv_rc" href="index.html">AndroidTVController.android_tv_rc</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="AndroidTVController.android_tv_rc.adb_client.ADBClient" href="#AndroidTVController.android_tv_rc.adb_client.ADBClient">ADBClient</a></code></h4>
<ul class="">
<li><code><a title="AndroidTVController.android_tv_rc.adb_client.ADBClient.clean" href="#AndroidTVController.android_tv_rc.adb_client.ADBClient.clean">clean</a></code></li>
<li><code><a title="AndroidTVController.android_tv_rc.adb_client.ADBClient.connect" href="#AndroidTVController.android_tv_rc.adb_client.ADBClient.connect">connect</a></code></li>
<li><code><a title="AndroidTVController.android_tv_rc.adb_client.ADBClient.disconnect" href="#AndroidTVController.android_tv_rc.adb_client.ADBClient.disconnect">disconnect</a></code></li>
<li><code><a title="AndroidTVController.android_tv_rc.adb_client.ADBClient.execute_shell_command" href="#AndroidTVController.android_tv_rc.adb_client.ADBClient.execute_shell_command">execute_shell_command</a></code></li>
<li><code><a title="AndroidTVController.android_tv_rc.adb_client.ADBClient.get_device_info" href="#AndroidTVController.android_tv_rc.adb_client.ADBClient.get_device_info">get_device_info</a></code></li>
<li><code><a title="AndroidTVController.android_tv_rc.adb_client.ADBClient.get_devices" href="#AndroidTVController.android_tv_rc.adb_client.ADBClient.get_devices">get_devices</a></code></li>
<li><code><a title="AndroidTVController.android_tv_rc.adb_client.ADBClient.get_devpath" href="#AndroidTVController.android_tv_rc.adb_client.ADBClient.get_devpath">get_devpath</a></code></li>
<li><code><a title="AndroidTVController.android_tv_rc.adb_client.ADBClient.get_ip_address" href="#AndroidTVController.android_tv_rc.adb_client.ADBClient.get_ip_address">get_ip_address</a></code></li>
<li><code><a title="AndroidTVController.android_tv_rc.adb_client.ADBClient.get_package_activities" href="#AndroidTVController.android_tv_rc.adb_client.ADBClient.get_package_activities">get_package_activities</a></code></li>
<li><code><a title="AndroidTVController.android_tv_rc.adb_client.ADBClient.get_selected_device" href="#AndroidTVController.android_tv_rc.adb_client.ADBClient.get_selected_device">get_selected_device</a></code></li>
<li><code><a title="AndroidTVController.android_tv_rc.adb_client.ADBClient.get_serialno" href="#AndroidTVController.android_tv_rc.adb_client.ADBClient.get_serialno">get_serialno</a></code></li>
<li><code><a title="AndroidTVController.android_tv_rc.adb_client.ADBClient.get_state" href="#AndroidTVController.android_tv_rc.adb_client.ADBClient.get_state">get_state</a></code></li>
<li><code><a title="AndroidTVController.android_tv_rc.adb_client.ADBClient.install" href="#AndroidTVController.android_tv_rc.adb_client.ADBClient.install">install</a></code></li>
<li><code><a title="AndroidTVController.android_tv_rc.adb_client.ADBClient.is_connected" href="#AndroidTVController.android_tv_rc.adb_client.ADBClient.is_connected">is_connected</a></code></li>
<li><code><a title="AndroidTVController.android_tv_rc.adb_client.ADBClient.is_installed" href="#AndroidTVController.android_tv_rc.adb_client.ADBClient.is_installed">is_installed</a></code></li>
<li><code><a title="AndroidTVController.android_tv_rc.adb_client.ADBClient.kill_server" href="#AndroidTVController.android_tv_rc.adb_client.ADBClient.kill_server">kill_server</a></code></li>
<li><code><a title="AndroidTVController.android_tv_rc.adb_client.ADBClient.list_packages" href="#AndroidTVController.android_tv_rc.adb_client.ADBClient.list_packages">list_packages</a></code></li>
<li><code><a title="AndroidTVController.android_tv_rc.adb_client.ADBClient.pull" href="#AndroidTVController.android_tv_rc.adb_client.ADBClient.pull">pull</a></code></li>
<li><code><a title="AndroidTVController.android_tv_rc.adb_client.ADBClient.push" href="#AndroidTVController.android_tv_rc.adb_client.ADBClient.push">push</a></code></li>
<li><code><a title="AndroidTVController.android_tv_rc.adb_client.ADBClient.reboot" href="#AndroidTVController.android_tv_rc.adb_client.ADBClient.reboot">reboot</a></code></li>
<li><code><a title="AndroidTVController.android_tv_rc.adb_client.ADBClient.select_device" href="#AndroidTVController.android_tv_rc.adb_client.ADBClient.select_device">select_device</a></code></li>
<li><code><a title="AndroidTVController.android_tv_rc.adb_client.ADBClient.send_keyevent_input" href="#AndroidTVController.android_tv_rc.adb_client.ADBClient.send_keyevent_input">send_keyevent_input</a></code></li>
<li><code><a title="AndroidTVController.android_tv_rc.adb_client.ADBClient.send_text_input" href="#AndroidTVController.android_tv_rc.adb_client.ADBClient.send_text_input">send_text_input</a></code></li>
<li><code><a title="AndroidTVController.android_tv_rc.adb_client.ADBClient.start_app" href="#AndroidTVController.android_tv_rc.adb_client.ADBClient.start_app">start_app</a></code></li>
<li><code><a title="AndroidTVController.android_tv_rc.adb_client.ADBClient.start_server" href="#AndroidTVController.android_tv_rc.adb_client.ADBClient.start_server">start_server</a></code></li>
<li><code><a title="AndroidTVController.android_tv_rc.adb_client.ADBClient.stop_app" href="#AndroidTVController.android_tv_rc.adb_client.ADBClient.stop_app">stop_app</a></code></li>
<li><code><a title="AndroidTVController.android_tv_rc.adb_client.ADBClient.uninstall" href="#AndroidTVController.android_tv_rc.adb_client.ADBClient.uninstall">uninstall</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
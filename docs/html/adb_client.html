<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>AndroidTVController.adb_client API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>AndroidTVController.adb_client</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import re
import sys
import shlex
import time
import subprocess
from typing import Any
from .logger import Logger
from .key_codes import KeyCodes



class ADBClient:
 


    def __init__(self, verbose: bool=False, show_command: bool=False):
        &#34;&#34;&#34;Pythonic way to interact with adb commands.
        
        The ADBClient class is used to interact with the ADB command-line tool in Python, allowing for
        communication with Android devices.
        1-Before running
            You need Android Platform Tools installed and available on your PATH environment variable.
            https://developer.android.com/studio/releases/platform-tools#download
            Ensure you run `adb tcpip 5555` to enable TCP mode.
        2-ADB commands references
            https://developer.android.com/tools/adb
            https://developer.android.com/studio/command-line/adb
            https://technastic.com/set-up-adb-over-wifi-android/
            https://technastic.com/adb-shell-commands-list/
            https://technastic.com/adb-commands-list-adb-cheat-sheet/
        
        Args:
            verbose (bool): The `verbose` parameter is a boolean flag that determines whether or not to
                enable verbose logging. If set to `True`, it will display additional information during the
                execution of the code. If set to `False` (default), it will not display any additional
                information. Defaults to False
            show_command (bool): The `show_command` parameter is a boolean flag that determines whether or
                not to display the executed ADB commands. If `show_command` is set to `True`, the executed ADB
                commands will be shown. If `show_command` is set to `False`, the executed ADB commands will.
                Defaults to False
        &#34;&#34;&#34;
        # logs verbose 
        self.__verbose = verbose
        self.__show_command = show_command
        if self.__verbose:
            Logger.welcome(&#39;use ADB command-line tool with python.&#39;)
        
        # adb params
        self.__devices = []
        self.__selected_device = None
        self.__server_process = None
        
        # start adb server to start sending commands to devices
        self.start_server()



    
    def __execute_command(self, command_str: str, blocking: bool=True) -&gt; Any:
        &#34;&#34;&#34;
        The function executes a shell command using the adb tool, with the option to run it in blocking
        or non-blocking mode.

        Args:
            command_str (str): The `command_str` parameter is a string that represents the shell command
                to be executed. It can be any valid adb command or a combination of adb commands.
            blocking (bool): The `blocking` parameter is a boolean flag that determines whether the
                command should be executed synchronously (blocking) or asynchronously (non-blocking). Defaults
                to True

        Returns:
            The method `__execute_command` returns the output of the shell command that is executed. If
            the `blocking` parameter is set to `True`, it returns the stdout of the command as a string. If
            `blocking` is set to `False`, it returns a `subprocess.Popen` object.
        &#34;&#34;&#34;
        command = &#39;adb &#39;
        if self.__selected_device is not None:
            command += f&#39;-s {self.__selected_device} &#39;
        command += command_str
        if self.__verbose and self.__show_command:
            Logger.info(f&#39;[bold]Command:[/bold] {command}&#39;)
        command_parts = shlex.split(command, posix=&#34;win&#34; not in sys.platform)
        if blocking:
            proc = subprocess.run(command_parts, check=True, capture_output=True, text=True)
            return proc.stdout.strip()
        else:
            return subprocess.Popen(command_parts, stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT)
    
    
    
    # ------------------------------[ Server Commands ]------------------------------



    def start_server(self):
        &#34;&#34;&#34;
        The function starts an ADB server and waits for it to start up.
        &#34;&#34;&#34;
        command = &#39;start-server&#39;
        if self.__verbose:
            Logger.success(&#39;ADB server is started&#39;)
        self.__server_process = self.__execute_command(command, False)
        time.sleep(5) # give time to start up



    def kill_server(self):
        &#34;&#34;&#34;
        The function `kill_server` stops the ADB server and terminates any running server process.
        &#34;&#34;&#34;
        command = &#39;kill-server&#39;
        self.__execute_command(command)
        if self.__server_process:
            self.__server_process.terminate()
        self.clean()
        if self.__verbose:
            Logger.success(&#39;ADB server is stopped&#39;)
    
    
    
    def clean(self):
        &#34;&#34;&#34;Resets and clean&#34;&#34;&#34;
        self.__devices = []
        self.__selected_device = None
        self.__server_process = None



    # ------------------------------[ Info Commands ]------------------------------
    
    
    
    def get_devices(self, include_descriptions: bool=True) -&gt; list:
        &#34;&#34;&#34;
        The function `get_devices` retrieves a list of connected devices, including their IP address,
        serial number, state, and optional descriptions.
        
        Args:
            include_descriptions (bool): The `include_descriptions` parameter is a boolean flag that
                determines whether or not to include descriptions for the connected devices. If set to `True`,
                the descriptions will be included in the returned list of devices. If set to `False`, the
                descriptions will be excluded. Defaults to True

        Returns:
            The method `get_devices` returns a list of dictionaries, where each dictionary represents a
            connected device. Each dictionary contains the following keys: &#39;ip&#39;, &#39;serial_number&#39;, &#39;state&#39;,
            and &#39;description&#39;.
        &#34;&#34;&#34;
        command = &#39;devices&#39;
        if include_descriptions:
            command += &#39; -l&#39;
        result = self.__execute_command(command)
        devices = result.split(&#34;\n&#34;)[1:]
        Logger.info(f&#39;There are {len(devices)} connected devices&#39;)
        for i, device in enumerate(devices):
            data = device.split()
            serial_number = data[0]
            ip = serial_number.split(&#39;:&#39;)[0]
            state = data[1]
            description = {}
            for meta in data[2:]:
                meta_pairs = meta.split(&#39;:&#39;)
                if len(meta_pairs) == 2:
                    description[meta_pairs[0]] = meta_pairs[1]
            self.__devices.append({&#39;ip&#39;: ip, &#39;serial_number&#39;: serial_number, &#39;state&#39;: state, &#39;description&#39;: description})
            if self.__verbose:
                Logger.print(f&#39;[bold green]Device[/bold green]: [yellow]{i+1}[/yellow]&#39;)
                Logger.print(f&#39;[bold green]IP address[/bold green]: [yellow]{ip}[/yellow]&#39;)
                Logger.print(f&#39;[bold green]Serial number[/bold green]: [yellow]{serial_number}[/yellow]&#39;)
                Logger.print(f&#39;[bold green]State[/bold green]: [yellow]{state}[/yellow]&#39;)
                for key, val in description.items():
                    Logger.print(f&#39;[bold green]{key.title()}[/bold green]: [yellow]{val}[/yellow]&#39;)
                Logger.print(&#39;\n&#39;)
        return self.__devices
    
    
    
    def select_device(self, device_serial: str):
        &#34;&#34;&#34;
        The function selects a device based on its serial number.
        
        Args:
            device_serial (str): The `device_serial` parameter is a string that represents the serial
                number of a device.
        &#34;&#34;&#34;
        self.__selected_device = device_serial
        
        
        
    def get_device_info(self) -&gt; dict:
        &#34;&#34;&#34;
        The function `get_device_info` retrieves device information.
        
        Returns:
            Dictionary containing device information.
        &#34;&#34;&#34;
        results = self.__execute_command(&#39;getprop&#39;).split(&#39;\n&#39;)
        device_info = {}
        for data in results:
            match = re.match(r&#34;\[([^:]+)\]: \[([^:]+)\]&#34;, data)
            if match:
                device_info[match.group(1)] = match.group(2)
        return device_info
       
       
       
    def get_state(self) -&gt; str:
        &#34;&#34;&#34;
        The function `get_state` returns the state of connected device.
        
        Returns:
            String represents device state.
        &#34;&#34;&#34;
        return self.__execute_command(&#39;get-state&#39;)



    def get_serialno(self) -&gt; str:
        &#34;&#34;&#34;
        The function `get_serialno` returns the serial number of a selected device.
        
        Returns:
            The method is returning the serial number of the selected device.
        &#34;&#34;&#34;
        if self.__selected_device:
            return self.__selected_device
        self.__selected_device = self.__execute_command(&#39;get-serialno&#39;)
        return self.__selected_device



    def get_devpath(self) -&gt; str:
        &#34;&#34;&#34;
        The function `get_devpath` retrieves the device path of a connected Android device&#39;.
        
        Returns:
            String represents the device path, for example usb:1-4.3 for usb connected device.
        &#34;&#34;&#34;
        return self.__execute_command(&#39;get-devpath&#39;)
    
    
    
    def get_ip_address(self, interface: str=&#39;wlan0&#39;) -&gt; Any:
        &#34;&#34;&#34;
        The function `get_ip_address` returns the device IP address of a specified network interface.
        
        Args:
            interface (str): The `interface` parameter is a string that specifies the network interface to
                retrieve the IP address from. In this case, the default value is set to &#34;wlan0&#34;, which is a
                common interface name for wireless LAN connections on Linux-based systems. Defaults to wlan0
        
        Returns:
            The IP address of the selected device.
        &#34;&#34;&#34;
        if self.__selected_device is not None:
            return self.__selected_device.split(&#39;:&#39;)[0]
        # if result := self.execute_shell_command(f&#39;ifconfig {interface}&#39;):
        #     if match_obj := re.search(r&#34;inet addr:(.+)  Bcast&#34;, result, re.M | re.I):
        #         return match_obj[1]
    
    

    # ------------------------------[ Connectivity Commands ]------------------------------



    def is_connected(self, ip: str) -&gt; bool:
        &#34;&#34;&#34;
        The function checks if a device with a given IP address is connected to adb server.
        
        Args:
            ip (str): The `ip` parameter is a string that represents an IP address.
        
        Returns:
            Boolean value. It returns True if there is a device in the list of devices with the
            specified IP address, and False otherwise.
        &#34;&#34;&#34;
        for device in self.__devices:
            if device[&#39;ip&#39;] == ip:
                return True
        return False



    def connect(self, ip: str):
        &#34;&#34;&#34;
        The function connects to an IP address and raises an error if the connection fails.
        
        Args:
            ip (str): The `ip` parameter in the `connect` method is a string that represents the IP
                address of the device you want to connect to.
                
        Raises:
            RuntimeError
        &#34;&#34;&#34;
        result = self.__execute_command(f&#39;connect {ip}&#39;)
        if &#34;failed&#34; in result:
            raise RuntimeError(f&#34;Unable to connect to {ip}&#34;)
        elif &#34;connected&#34; in result:
            self.__selected_device = self.get_serialno()



    def disconnect(self) -&gt; str:
        &#34;&#34;&#34;
        Disconnect device.
        
        Returns:
            String of the disconnect process result.
        &#34;&#34;&#34;
        return self.__execute_command(&#39;disconnect&#39;)


 
    # ------------------------------[ File Operations Commands ]------------------------------



    def push(self, local: str, remote: str=&#39;/data/local/tmp/&#39;) -&gt; str:
        &#34;&#34;&#34;
        Copy files and directories from the local device (computer) to
        a remote location on the device.
        
        Args:
            local (str): The `local` parameter is a string that represents the path of the file or
                directory on the local device (computer) that you want to copy to the remote location on the
                device.
            remote (str): The `remote` parameter is a string that specifies the destination location on
                the device where the files or directories from the local device will be copied to. By default,
                the destination location is set to `/data/local/tmp/`, but you can provide a different path if
                needed. Defaults to /data/local/tmp/
        
        Returns:
            String of the file upload process result.
        &#34;&#34;&#34;
        return self.__execute_command(f&#39;push {local} {remote}&#39;)



    def pull(self, remote: str, local: str, preserve_meta: bool=False) -&gt; str:
        &#34;&#34;&#34;
        The function `pull` copies remote files and directories to a device, with an option to preserve
        file metadata like time stamp and mode.
        
        Args:
            remote (str): The `remote` parameter is a string that represents the path of the remote file
                or directory that you want to copy to the device.
            local (str): The &#34;local&#34; parameter is a string that represents the local directory or file
                path where the remote files and directories will be copied to.
            preserve_meta (bool): The `preserve_meta` parameter is a boolean flag that determines whether
                to preserve the file time stamp and mode during the file transfer process. If `preserve_meta` is
                set to `True`, the `-k` option will be added to the command, indicating that the file time stamp
                and mode should be. Defaults to False
        
        Returns:
            String of the file download process result.
        &#34;&#34;&#34;
        command = &#39;pull &#39;
        if preserve_meta:
            command += &#39;-k &#39;
        command += f&#39;{remote} {local}&#39;
        return self.__execute_command(command)



    # ------------------------------[ Apps Operations Commands ]------------------------------
    


    def is_installed(self, package_name: str) -&gt; bool:
        &#34;&#34;&#34;
        The function checks if the specified package is installed or not.
        
        Args:
            package_name (str): The name of the package, for example &#39;com.google.chrome&#39;
        
        Returns:
            Boolean indicates if app is installed or not.
        &#34;&#34;&#34;
        command = f&#39;pm list packages | grep {package_name}&#39;
        return len(self.execute_shell_command(command)) &gt; 0
        
        
        
    def install(self, apk_file: str, replace: bool=True) -&gt; str:
        &#34;&#34;&#34;
        The function installs an APK file on a device, with an option to replace/update an existing
        installation.
        
        Args:
            apk_file (str): The `apk_file` parameter is a string that represents the file path of the APK
                file that you want to install.
            replace (bool): The `replace` parameter is a boolean value that determines whether to replace
                an existing installation of the APK file. If `replace` is set to `True`, the existing
                installation will be replaced. If `replace` is set to `False`, the existing installation will
                not be replaced and an error will. Defaults to True
        
        Returns:
            String of the app installation process result.
        &#34;&#34;&#34;
        command = &#39;install &#39;
        if replace:
            command += &#39;-r &#39;
        command += apk_file
        return self.__execute_command(command)



    def uninstall(self, package: str, keep_data: bool=False) -&gt; str:
        &#34;&#34;&#34;
        The `uninstall` function removes an app package from a device, with an option to keep the data
        and cache directories.
        
        Args:
            package (str): The package parameter is a string that represents the app package name that you
                want to uninstall from the device.
            keep_data (bool): A boolean parameter that determines whether to keep the data and cache
                directories of the app package when uninstalling. If set to True, the directories will be kept.
                If set to False (default), the directories will be removed along with the app package. Defaults
                to False
        
        Returns:
            String of the app removal process result.
        &#34;&#34;&#34;
        command = &#39;uninstall &#39;
        if keep_data:
            command += &#39;-k &#39;
        command += package
        return self.__execute_command(command)
    
    
    
    def start_app(self, package: str, activity: str, wait: bool=True, stop: bool=True) -&gt; str:
        &#34;&#34;&#34;
        The function starts an Android app with the specified package and activity, optionally waiting
        for the launch to complete and stopping the app before starting the activity.
        
        Args:
            package (str): The package parameter is a string that represents the package name of the
                Android application you want to start. This is typically the unique identifier for the app and
                is specified in the AndroidManifest.xml file of the app.
            activity (str): The &#34;activity&#34; parameter refers to the specific activity or screen within the
                Android app that you want to start. An activity represents a single screen with a user
                interface, and it is the basic building block of an Android app. Each activity has a unique name
                that is specified in the AndroidManifest.xml file
            wait (bool): The &#34;wait&#34; parameter is a boolean value that determines whether the command
                should wait for the launch to complete before returning. If set to True, the command will wait
                for the launch to complete. If set to False, the command will not wait and will return
                immediately after starting the activity. Defaults to True
            stop (bool): The &#34;stop&#34; parameter is a boolean value that determines whether to force stop the
                target app before starting the activity. If it is set to True, the target app will be stopped
                before starting the activity. If it is set to False, the target app will not be stopped.
                Defaults to True
        
        Returns:
            String of the app launch process result.
        &#34;&#34;&#34;
        command = &#39;am start &#39;
        # wait for launch to complete
        if wait:
            command += &#39;-W &#39;
        if stop: # force stop the target app before starting the activity
            command += &#39;-S &#39;
        command += f&#39;{package}/{activity}&#39;
        return self.execute_shell_command(command)



    def stop_app(self, package: str) -&gt; str:
        &#34;&#34;&#34;
        The function stops an Android app with the specified package.
        
        Args:
            package (str): The package parameter is a string that represents the package name of the app
                you want to stop.
        
        Returns:
            String of the app stopping process result.
        &#34;&#34;&#34;
        return self.execute_shell_command(f&#39;am force-stop {package}&#39;)



    def list_packages(self, package_type: str=&#39;all&#39;) -&gt; list:
        &#34;&#34;&#34;
        The function &#34;list_packages&#34; lists device android packages, you can also filter package type.
        
        Args:
            package_type (str): The `package_type` parameter is a string that specifies the type of
                packages to list. It has a default value of `all` that gets all packages on the device,
                but it can also take the following values: [all | enabled | disabled | system | third-party].
                Defaults to all
        
        Returns:
            List of packages.
        &#34;&#34;&#34;
        package_type_flags = {&#39;all&#39;: &#39;&#39;, &#39;enabled&#39;: &#39;-e&#39;, &#39;disabled&#39;: &#39;-d&#39;, &#39;system&#39;: &#39;-s&#39;, &#39;third-party&#39;: &#39;-3&#39;}
        if package_type not in package_type_flags:
            package_type = &#39;all&#39;
        results = self.execute_shell_command(f&#39;pm list packages {package_type_flags[package_type]}&#39;).split(&#34;\n&#34;)
        packages = sorted([x.replace(&#39;package:&#39;, &#39;&#39;) for x in results])
        if self.__verbose:
            for package in packages:
                Logger.print(f&#39;[bold green]{package}[/bold green]&#39;)
        return packages
    
    
    
    def get_package_activities(self, package: str) -&gt; list:
        &#34;&#34;&#34;
        The function `get_package_activities` retrieves the activities associated with a given package
        in order to start the app.
        
        Args:
            package (str): The &#34;package&#34; parameter is a string that represents the name of the package for
                which you want to retrieve the activities.
        
        Returns:
            List of package activities.
        &#34;&#34;&#34;
        &#39;&#39;&#39;Get package activities, this is useful to be able to start the app&#39;&#39;&#39;
        results = self.execute_shell_command(f&#39;dumpsys package {package}&#39;).split()
        activities = set()
        for res in results:
            if &#39;activity&#39; in res.lower() and &#39;com&#39; in res.lower():
                activities.add(res.replace(&#39;&#34;&#39;, &#39;&#39;).strip())
        return list(activities)



    # def kill_all(self):
    #     &#34;&#34;&#34;
    #     Kill all background processes.
    #     &#34;&#34;&#34;
    #     return self.execute_shell_command(&#39;am kill-all&#39;)



    # ------------------------------[ Device related Commands ]------------------------------



    def reboot(self, mode: str|None=None) -&gt; str:
        &#34;&#34;&#34;
        The function `reboot` reboots the device with the specified mode, or with no mode if none is
        provided.
        
        Args:
            mode (str|None): The `mode` parameter is a string that specifies the type of reboot to
                perform. It can have one of the following values: [bootloader | recovery | sideload | sideload-auto-reboot]
        
        Returns:
            The method is returning the result of executing the reboot command on the device.
        &#34;&#34;&#34;
        command = &#39;reboot &#39;
        if mode:
            command += mode
        return self.__execute_command(command)
    
    
    
    def execute_shell_command(self, command: str) -&gt; str:
        &#34;&#34;&#34;
        The function executes an adb shell command by calling `adb shell` command.
        
        Args:
            command (str): The `command` parameter is a string that represents the shell command that you
                want to execute.
        
        Returns:
            String of the output results of executing the shell command.
        &#34;&#34;&#34;
        return self.__execute_command(f&#39;shell {command}&#39;)



    # ------------------------------[ Services Commands ]------------------------------
    


    def list_services(self) -&gt; list:
        &#34;&#34;&#34;
        The `list_services` function retrieves a list of services along with their IDs, names, and
        associated packages.
        
        Returns:
            List of dictionaries, where each dictionary represents a service. Each dictionary contains
            the following keys: &#39;id&#39; (integer), &#39;name&#39; (string), and &#39;package&#39; (string).
        &#34;&#34;&#34;
        results = self.execute_shell_command(&#39;service list&#39;)
        lines = results.split(&#34;\n&#34;)
        lines = lines[1:]
        services = []
        pattern = r&#34;(\d+)\t(\w+):\s+\[(.*?)\]&#34;
        for line in lines:
            if match := re.search(pattern, line):
                service_id = int(match[1])
                service_name = match[2]
                service_process = match[3]
                service_info = {&#39;id&#39;: service_id, &#39;name&#39;: service_name, &#39;package&#39;: service_process}
                services.append(service_info)
        return services



    def start_service(self, service: str) -&gt; str:
        &#34;&#34;&#34;
        The function executes an adb shell command to start a service.
        
        Args:
            service (str): The `service` parameter is a string that represents service name that you
                want to start.
        
        Returns:
            String of the output results of service starting processing.
        &#34;&#34;&#34;
        return self.execute_shell_command(f&#39;am startservice {service}&#39;)



    def stop_service(self, service: str) -&gt; str:
        &#34;&#34;&#34;
        The function executes an adb shell command to stop a running service.
        
        Args:
            service (str): The `service` parameter is a string that represents service name that you
                want to stop.
        
        Returns:
            String of the output results of service stopping processing.
        &#34;&#34;&#34;
        return self.execute_shell_command(f&#39;am stopservice {service}&#39;)
        # return self.execute_shell_command(f&#39;am force-stop {service}&#39;)



    # ------------------------------[ Inputs Commands ]------------------------------



    def send_keyevent_input(self, keycode: KeyCodes, long_press: bool=False) -&gt; str:
        &#34;&#34;&#34;
        The function executes an adb shell command to send key event input that simulates pressing button keys.
        
        Args:
            keycode (KeyCode): the keycode to send, table of key codes: https://www.temblast.com/ref/akeyscode.htm
            long_press (bool): specify if simulate a long press for the key or not. Defaults to False.
        
        Returns:
            String of the output results of sending input.
        &#34;&#34;&#34;
        command = f&#39;input keyevent {keycode.name}&#39;
        if long_press:
            command += &#39;--longpress&#39;
        return self.execute_shell_command(command)
    
    
    
    def send_text_input(self, text: str, encode_spaces: bool=True):
        &#34;&#34;&#34;
        The function executes an adb shell command to send text input.
        
        Args:
            text (str): the text string to send.
            encode_spaces (bool): specify if spaces should be replaced by `%s` or not. Defaults to True.
        
        Returns:
            String of the output results of sending input.
        &#34;&#34;&#34;
        &#39;&#39;&#39;Send text.&#39;&#39;&#39;
        processed_text = text.replace(&#39; &#39;, &#39;%s&#39;) if encode_spaces else text
        return self.execute_shell_command(f&#39;input text {processed_text}&#39;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="AndroidTVController.adb_client.ADBClient"><code class="flex name class">
<span>class <span class="ident">ADBClient</span></span>
<span>(</span><span>verbose: bool = False, show_command: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Pythonic way to interact with adb commands.</p>
<p>The ADBClient class is used to interact with the ADB command-line tool in Python, allowing for
communication with Android devices.
1-Before running
You need Android Platform Tools installed and available on your PATH environment variable.
<a href="https://developer.android.com/studio/releases/platform-tools#download">https://developer.android.com/studio/releases/platform-tools#download</a>
Ensure you run <code>adb tcpip 5555</code> to enable TCP mode.
2-ADB commands references
<a href="https://developer.android.com/tools/adb">https://developer.android.com/tools/adb</a>
<a href="https://developer.android.com/studio/command-line/adb">https://developer.android.com/studio/command-line/adb</a>
<a href="https://technastic.com/set-up-adb-over-wifi-android/">https://technastic.com/set-up-adb-over-wifi-android/</a>
<a href="https://technastic.com/adb-shell-commands-list/">https://technastic.com/adb-shell-commands-list/</a>
<a href="https://technastic.com/adb-commands-list-adb-cheat-sheet/">https://technastic.com/adb-commands-list-adb-cheat-sheet/</a></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code></dt>
<dd>The <code>verbose</code> parameter is a boolean flag that determines whether or not to
enable verbose logging. If set to <code>True</code>, it will display additional information during the
execution of the code. If set to <code>False</code> (default), it will not display any additional
information. Defaults to False</dd>
<dt><strong><code>show_command</code></strong> :&ensp;<code>bool</code></dt>
<dd>The <code>show_command</code> parameter is a boolean flag that determines whether or
not to display the executed ADB commands. If <code>show_command</code> is set to <code>True</code>, the executed ADB
commands will be shown. If <code>show_command</code> is set to <code>False</code>, the executed ADB commands will.
Defaults to False</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ADBClient:
 


    def __init__(self, verbose: bool=False, show_command: bool=False):
        &#34;&#34;&#34;Pythonic way to interact with adb commands.
        
        The ADBClient class is used to interact with the ADB command-line tool in Python, allowing for
        communication with Android devices.
        1-Before running
            You need Android Platform Tools installed and available on your PATH environment variable.
            https://developer.android.com/studio/releases/platform-tools#download
            Ensure you run `adb tcpip 5555` to enable TCP mode.
        2-ADB commands references
            https://developer.android.com/tools/adb
            https://developer.android.com/studio/command-line/adb
            https://technastic.com/set-up-adb-over-wifi-android/
            https://technastic.com/adb-shell-commands-list/
            https://technastic.com/adb-commands-list-adb-cheat-sheet/
        
        Args:
            verbose (bool): The `verbose` parameter is a boolean flag that determines whether or not to
                enable verbose logging. If set to `True`, it will display additional information during the
                execution of the code. If set to `False` (default), it will not display any additional
                information. Defaults to False
            show_command (bool): The `show_command` parameter is a boolean flag that determines whether or
                not to display the executed ADB commands. If `show_command` is set to `True`, the executed ADB
                commands will be shown. If `show_command` is set to `False`, the executed ADB commands will.
                Defaults to False
        &#34;&#34;&#34;
        # logs verbose 
        self.__verbose = verbose
        self.__show_command = show_command
        if self.__verbose:
            Logger.welcome(&#39;use ADB command-line tool with python.&#39;)
        
        # adb params
        self.__devices = []
        self.__selected_device = None
        self.__server_process = None
        
        # start adb server to start sending commands to devices
        self.start_server()



    
    def __execute_command(self, command_str: str, blocking: bool=True) -&gt; Any:
        &#34;&#34;&#34;
        The function executes a shell command using the adb tool, with the option to run it in blocking
        or non-blocking mode.

        Args:
            command_str (str): The `command_str` parameter is a string that represents the shell command
                to be executed. It can be any valid adb command or a combination of adb commands.
            blocking (bool): The `blocking` parameter is a boolean flag that determines whether the
                command should be executed synchronously (blocking) or asynchronously (non-blocking). Defaults
                to True

        Returns:
            The method `__execute_command` returns the output of the shell command that is executed. If
            the `blocking` parameter is set to `True`, it returns the stdout of the command as a string. If
            `blocking` is set to `False`, it returns a `subprocess.Popen` object.
        &#34;&#34;&#34;
        command = &#39;adb &#39;
        if self.__selected_device is not None:
            command += f&#39;-s {self.__selected_device} &#39;
        command += command_str
        if self.__verbose and self.__show_command:
            Logger.info(f&#39;[bold]Command:[/bold] {command}&#39;)
        command_parts = shlex.split(command, posix=&#34;win&#34; not in sys.platform)
        if blocking:
            proc = subprocess.run(command_parts, check=True, capture_output=True, text=True)
            return proc.stdout.strip()
        else:
            return subprocess.Popen(command_parts, stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT)
    
    
    
    # ------------------------------[ Server Commands ]------------------------------



    def start_server(self):
        &#34;&#34;&#34;
        The function starts an ADB server and waits for it to start up.
        &#34;&#34;&#34;
        command = &#39;start-server&#39;
        if self.__verbose:
            Logger.success(&#39;ADB server is started&#39;)
        self.__server_process = self.__execute_command(command, False)
        time.sleep(5) # give time to start up



    def kill_server(self):
        &#34;&#34;&#34;
        The function `kill_server` stops the ADB server and terminates any running server process.
        &#34;&#34;&#34;
        command = &#39;kill-server&#39;
        self.__execute_command(command)
        if self.__server_process:
            self.__server_process.terminate()
        self.clean()
        if self.__verbose:
            Logger.success(&#39;ADB server is stopped&#39;)
    
    
    
    def clean(self):
        &#34;&#34;&#34;Resets and clean&#34;&#34;&#34;
        self.__devices = []
        self.__selected_device = None
        self.__server_process = None



    # ------------------------------[ Info Commands ]------------------------------
    
    
    
    def get_devices(self, include_descriptions: bool=True) -&gt; list:
        &#34;&#34;&#34;
        The function `get_devices` retrieves a list of connected devices, including their IP address,
        serial number, state, and optional descriptions.
        
        Args:
            include_descriptions (bool): The `include_descriptions` parameter is a boolean flag that
                determines whether or not to include descriptions for the connected devices. If set to `True`,
                the descriptions will be included in the returned list of devices. If set to `False`, the
                descriptions will be excluded. Defaults to True

        Returns:
            The method `get_devices` returns a list of dictionaries, where each dictionary represents a
            connected device. Each dictionary contains the following keys: &#39;ip&#39;, &#39;serial_number&#39;, &#39;state&#39;,
            and &#39;description&#39;.
        &#34;&#34;&#34;
        command = &#39;devices&#39;
        if include_descriptions:
            command += &#39; -l&#39;
        result = self.__execute_command(command)
        devices = result.split(&#34;\n&#34;)[1:]
        Logger.info(f&#39;There are {len(devices)} connected devices&#39;)
        for i, device in enumerate(devices):
            data = device.split()
            serial_number = data[0]
            ip = serial_number.split(&#39;:&#39;)[0]
            state = data[1]
            description = {}
            for meta in data[2:]:
                meta_pairs = meta.split(&#39;:&#39;)
                if len(meta_pairs) == 2:
                    description[meta_pairs[0]] = meta_pairs[1]
            self.__devices.append({&#39;ip&#39;: ip, &#39;serial_number&#39;: serial_number, &#39;state&#39;: state, &#39;description&#39;: description})
            if self.__verbose:
                Logger.print(f&#39;[bold green]Device[/bold green]: [yellow]{i+1}[/yellow]&#39;)
                Logger.print(f&#39;[bold green]IP address[/bold green]: [yellow]{ip}[/yellow]&#39;)
                Logger.print(f&#39;[bold green]Serial number[/bold green]: [yellow]{serial_number}[/yellow]&#39;)
                Logger.print(f&#39;[bold green]State[/bold green]: [yellow]{state}[/yellow]&#39;)
                for key, val in description.items():
                    Logger.print(f&#39;[bold green]{key.title()}[/bold green]: [yellow]{val}[/yellow]&#39;)
                Logger.print(&#39;\n&#39;)
        return self.__devices
    
    
    
    def select_device(self, device_serial: str):
        &#34;&#34;&#34;
        The function selects a device based on its serial number.
        
        Args:
            device_serial (str): The `device_serial` parameter is a string that represents the serial
                number of a device.
        &#34;&#34;&#34;
        self.__selected_device = device_serial
        
        
        
    def get_device_info(self) -&gt; dict:
        &#34;&#34;&#34;
        The function `get_device_info` retrieves device information.
        
        Returns:
            Dictionary containing device information.
        &#34;&#34;&#34;
        results = self.__execute_command(&#39;getprop&#39;).split(&#39;\n&#39;)
        device_info = {}
        for data in results:
            match = re.match(r&#34;\[([^:]+)\]: \[([^:]+)\]&#34;, data)
            if match:
                device_info[match.group(1)] = match.group(2)
        return device_info
       
       
       
    def get_state(self) -&gt; str:
        &#34;&#34;&#34;
        The function `get_state` returns the state of connected device.
        
        Returns:
            String represents device state.
        &#34;&#34;&#34;
        return self.__execute_command(&#39;get-state&#39;)



    def get_serialno(self) -&gt; str:
        &#34;&#34;&#34;
        The function `get_serialno` returns the serial number of a selected device.
        
        Returns:
            The method is returning the serial number of the selected device.
        &#34;&#34;&#34;
        if self.__selected_device:
            return self.__selected_device
        self.__selected_device = self.__execute_command(&#39;get-serialno&#39;)
        return self.__selected_device



    def get_devpath(self) -&gt; str:
        &#34;&#34;&#34;
        The function `get_devpath` retrieves the device path of a connected Android device&#39;.
        
        Returns:
            String represents the device path, for example usb:1-4.3 for usb connected device.
        &#34;&#34;&#34;
        return self.__execute_command(&#39;get-devpath&#39;)
    
    
    
    def get_ip_address(self, interface: str=&#39;wlan0&#39;) -&gt; Any:
        &#34;&#34;&#34;
        The function `get_ip_address` returns the device IP address of a specified network interface.
        
        Args:
            interface (str): The `interface` parameter is a string that specifies the network interface to
                retrieve the IP address from. In this case, the default value is set to &#34;wlan0&#34;, which is a
                common interface name for wireless LAN connections on Linux-based systems. Defaults to wlan0
        
        Returns:
            The IP address of the selected device.
        &#34;&#34;&#34;
        if self.__selected_device is not None:
            return self.__selected_device.split(&#39;:&#39;)[0]
        # if result := self.execute_shell_command(f&#39;ifconfig {interface}&#39;):
        #     if match_obj := re.search(r&#34;inet addr:(.+)  Bcast&#34;, result, re.M | re.I):
        #         return match_obj[1]
    
    

    # ------------------------------[ Connectivity Commands ]------------------------------



    def is_connected(self, ip: str) -&gt; bool:
        &#34;&#34;&#34;
        The function checks if a device with a given IP address is connected to adb server.
        
        Args:
            ip (str): The `ip` parameter is a string that represents an IP address.
        
        Returns:
            Boolean value. It returns True if there is a device in the list of devices with the
            specified IP address, and False otherwise.
        &#34;&#34;&#34;
        for device in self.__devices:
            if device[&#39;ip&#39;] == ip:
                return True
        return False



    def connect(self, ip: str):
        &#34;&#34;&#34;
        The function connects to an IP address and raises an error if the connection fails.
        
        Args:
            ip (str): The `ip` parameter in the `connect` method is a string that represents the IP
                address of the device you want to connect to.
                
        Raises:
            RuntimeError
        &#34;&#34;&#34;
        result = self.__execute_command(f&#39;connect {ip}&#39;)
        if &#34;failed&#34; in result:
            raise RuntimeError(f&#34;Unable to connect to {ip}&#34;)
        elif &#34;connected&#34; in result:
            self.__selected_device = self.get_serialno()



    def disconnect(self) -&gt; str:
        &#34;&#34;&#34;
        Disconnect device.
        
        Returns:
            String of the disconnect process result.
        &#34;&#34;&#34;
        return self.__execute_command(&#39;disconnect&#39;)


 
    # ------------------------------[ File Operations Commands ]------------------------------



    def push(self, local: str, remote: str=&#39;/data/local/tmp/&#39;) -&gt; str:
        &#34;&#34;&#34;
        Copy files and directories from the local device (computer) to
        a remote location on the device.
        
        Args:
            local (str): The `local` parameter is a string that represents the path of the file or
                directory on the local device (computer) that you want to copy to the remote location on the
                device.
            remote (str): The `remote` parameter is a string that specifies the destination location on
                the device where the files or directories from the local device will be copied to. By default,
                the destination location is set to `/data/local/tmp/`, but you can provide a different path if
                needed. Defaults to /data/local/tmp/
        
        Returns:
            String of the file upload process result.
        &#34;&#34;&#34;
        return self.__execute_command(f&#39;push {local} {remote}&#39;)



    def pull(self, remote: str, local: str, preserve_meta: bool=False) -&gt; str:
        &#34;&#34;&#34;
        The function `pull` copies remote files and directories to a device, with an option to preserve
        file metadata like time stamp and mode.
        
        Args:
            remote (str): The `remote` parameter is a string that represents the path of the remote file
                or directory that you want to copy to the device.
            local (str): The &#34;local&#34; parameter is a string that represents the local directory or file
                path where the remote files and directories will be copied to.
            preserve_meta (bool): The `preserve_meta` parameter is a boolean flag that determines whether
                to preserve the file time stamp and mode during the file transfer process. If `preserve_meta` is
                set to `True`, the `-k` option will be added to the command, indicating that the file time stamp
                and mode should be. Defaults to False
        
        Returns:
            String of the file download process result.
        &#34;&#34;&#34;
        command = &#39;pull &#39;
        if preserve_meta:
            command += &#39;-k &#39;
        command += f&#39;{remote} {local}&#39;
        return self.__execute_command(command)



    # ------------------------------[ Apps Operations Commands ]------------------------------
    


    def is_installed(self, package_name: str) -&gt; bool:
        &#34;&#34;&#34;
        The function checks if the specified package is installed or not.
        
        Args:
            package_name (str): The name of the package, for example &#39;com.google.chrome&#39;
        
        Returns:
            Boolean indicates if app is installed or not.
        &#34;&#34;&#34;
        command = f&#39;pm list packages | grep {package_name}&#39;
        return len(self.execute_shell_command(command)) &gt; 0
        
        
        
    def install(self, apk_file: str, replace: bool=True) -&gt; str:
        &#34;&#34;&#34;
        The function installs an APK file on a device, with an option to replace/update an existing
        installation.
        
        Args:
            apk_file (str): The `apk_file` parameter is a string that represents the file path of the APK
                file that you want to install.
            replace (bool): The `replace` parameter is a boolean value that determines whether to replace
                an existing installation of the APK file. If `replace` is set to `True`, the existing
                installation will be replaced. If `replace` is set to `False`, the existing installation will
                not be replaced and an error will. Defaults to True
        
        Returns:
            String of the app installation process result.
        &#34;&#34;&#34;
        command = &#39;install &#39;
        if replace:
            command += &#39;-r &#39;
        command += apk_file
        return self.__execute_command(command)



    def uninstall(self, package: str, keep_data: bool=False) -&gt; str:
        &#34;&#34;&#34;
        The `uninstall` function removes an app package from a device, with an option to keep the data
        and cache directories.
        
        Args:
            package (str): The package parameter is a string that represents the app package name that you
                want to uninstall from the device.
            keep_data (bool): A boolean parameter that determines whether to keep the data and cache
                directories of the app package when uninstalling. If set to True, the directories will be kept.
                If set to False (default), the directories will be removed along with the app package. Defaults
                to False
        
        Returns:
            String of the app removal process result.
        &#34;&#34;&#34;
        command = &#39;uninstall &#39;
        if keep_data:
            command += &#39;-k &#39;
        command += package
        return self.__execute_command(command)
    
    
    
    def start_app(self, package: str, activity: str, wait: bool=True, stop: bool=True) -&gt; str:
        &#34;&#34;&#34;
        The function starts an Android app with the specified package and activity, optionally waiting
        for the launch to complete and stopping the app before starting the activity.
        
        Args:
            package (str): The package parameter is a string that represents the package name of the
                Android application you want to start. This is typically the unique identifier for the app and
                is specified in the AndroidManifest.xml file of the app.
            activity (str): The &#34;activity&#34; parameter refers to the specific activity or screen within the
                Android app that you want to start. An activity represents a single screen with a user
                interface, and it is the basic building block of an Android app. Each activity has a unique name
                that is specified in the AndroidManifest.xml file
            wait (bool): The &#34;wait&#34; parameter is a boolean value that determines whether the command
                should wait for the launch to complete before returning. If set to True, the command will wait
                for the launch to complete. If set to False, the command will not wait and will return
                immediately after starting the activity. Defaults to True
            stop (bool): The &#34;stop&#34; parameter is a boolean value that determines whether to force stop the
                target app before starting the activity. If it is set to True, the target app will be stopped
                before starting the activity. If it is set to False, the target app will not be stopped.
                Defaults to True
        
        Returns:
            String of the app launch process result.
        &#34;&#34;&#34;
        command = &#39;am start &#39;
        # wait for launch to complete
        if wait:
            command += &#39;-W &#39;
        if stop: # force stop the target app before starting the activity
            command += &#39;-S &#39;
        command += f&#39;{package}/{activity}&#39;
        return self.execute_shell_command(command)



    def stop_app(self, package: str) -&gt; str:
        &#34;&#34;&#34;
        The function stops an Android app with the specified package.
        
        Args:
            package (str): The package parameter is a string that represents the package name of the app
                you want to stop.
        
        Returns:
            String of the app stopping process result.
        &#34;&#34;&#34;
        return self.execute_shell_command(f&#39;am force-stop {package}&#39;)



    def list_packages(self, package_type: str=&#39;all&#39;) -&gt; list:
        &#34;&#34;&#34;
        The function &#34;list_packages&#34; lists device android packages, you can also filter package type.
        
        Args:
            package_type (str): The `package_type` parameter is a string that specifies the type of
                packages to list. It has a default value of `all` that gets all packages on the device,
                but it can also take the following values: [all | enabled | disabled | system | third-party].
                Defaults to all
        
        Returns:
            List of packages.
        &#34;&#34;&#34;
        package_type_flags = {&#39;all&#39;: &#39;&#39;, &#39;enabled&#39;: &#39;-e&#39;, &#39;disabled&#39;: &#39;-d&#39;, &#39;system&#39;: &#39;-s&#39;, &#39;third-party&#39;: &#39;-3&#39;}
        if package_type not in package_type_flags:
            package_type = &#39;all&#39;
        results = self.execute_shell_command(f&#39;pm list packages {package_type_flags[package_type]}&#39;).split(&#34;\n&#34;)
        packages = sorted([x.replace(&#39;package:&#39;, &#39;&#39;) for x in results])
        if self.__verbose:
            for package in packages:
                Logger.print(f&#39;[bold green]{package}[/bold green]&#39;)
        return packages
    
    
    
    def get_package_activities(self, package: str) -&gt; list:
        &#34;&#34;&#34;
        The function `get_package_activities` retrieves the activities associated with a given package
        in order to start the app.
        
        Args:
            package (str): The &#34;package&#34; parameter is a string that represents the name of the package for
                which you want to retrieve the activities.
        
        Returns:
            List of package activities.
        &#34;&#34;&#34;
        &#39;&#39;&#39;Get package activities, this is useful to be able to start the app&#39;&#39;&#39;
        results = self.execute_shell_command(f&#39;dumpsys package {package}&#39;).split()
        activities = set()
        for res in results:
            if &#39;activity&#39; in res.lower() and &#39;com&#39; in res.lower():
                activities.add(res.replace(&#39;&#34;&#39;, &#39;&#39;).strip())
        return list(activities)



    # def kill_all(self):
    #     &#34;&#34;&#34;
    #     Kill all background processes.
    #     &#34;&#34;&#34;
    #     return self.execute_shell_command(&#39;am kill-all&#39;)



    # ------------------------------[ Device related Commands ]------------------------------



    def reboot(self, mode: str|None=None) -&gt; str:
        &#34;&#34;&#34;
        The function `reboot` reboots the device with the specified mode, or with no mode if none is
        provided.
        
        Args:
            mode (str|None): The `mode` parameter is a string that specifies the type of reboot to
                perform. It can have one of the following values: [bootloader | recovery | sideload | sideload-auto-reboot]
        
        Returns:
            The method is returning the result of executing the reboot command on the device.
        &#34;&#34;&#34;
        command = &#39;reboot &#39;
        if mode:
            command += mode
        return self.__execute_command(command)
    
    
    
    def execute_shell_command(self, command: str) -&gt; str:
        &#34;&#34;&#34;
        The function executes an adb shell command by calling `adb shell` command.
        
        Args:
            command (str): The `command` parameter is a string that represents the shell command that you
                want to execute.
        
        Returns:
            String of the output results of executing the shell command.
        &#34;&#34;&#34;
        return self.__execute_command(f&#39;shell {command}&#39;)



    # ------------------------------[ Services Commands ]------------------------------
    


    def list_services(self) -&gt; list:
        &#34;&#34;&#34;
        The `list_services` function retrieves a list of services along with their IDs, names, and
        associated packages.
        
        Returns:
            List of dictionaries, where each dictionary represents a service. Each dictionary contains
            the following keys: &#39;id&#39; (integer), &#39;name&#39; (string), and &#39;package&#39; (string).
        &#34;&#34;&#34;
        results = self.execute_shell_command(&#39;service list&#39;)
        lines = results.split(&#34;\n&#34;)
        lines = lines[1:]
        services = []
        pattern = r&#34;(\d+)\t(\w+):\s+\[(.*?)\]&#34;
        for line in lines:
            if match := re.search(pattern, line):
                service_id = int(match[1])
                service_name = match[2]
                service_process = match[3]
                service_info = {&#39;id&#39;: service_id, &#39;name&#39;: service_name, &#39;package&#39;: service_process}
                services.append(service_info)
        return services



    def start_service(self, service: str) -&gt; str:
        &#34;&#34;&#34;
        The function executes an adb shell command to start a service.
        
        Args:
            service (str): The `service` parameter is a string that represents service name that you
                want to start.
        
        Returns:
            String of the output results of service starting processing.
        &#34;&#34;&#34;
        return self.execute_shell_command(f&#39;am startservice {service}&#39;)



    def stop_service(self, service: str) -&gt; str:
        &#34;&#34;&#34;
        The function executes an adb shell command to stop a running service.
        
        Args:
            service (str): The `service` parameter is a string that represents service name that you
                want to stop.
        
        Returns:
            String of the output results of service stopping processing.
        &#34;&#34;&#34;
        return self.execute_shell_command(f&#39;am stopservice {service}&#39;)
        # return self.execute_shell_command(f&#39;am force-stop {service}&#39;)



    # ------------------------------[ Inputs Commands ]------------------------------



    def send_keyevent_input(self, keycode: KeyCodes, long_press: bool=False) -&gt; str:
        &#34;&#34;&#34;
        The function executes an adb shell command to send key event input that simulates pressing button keys.
        
        Args:
            keycode (KeyCode): the keycode to send, table of key codes: https://www.temblast.com/ref/akeyscode.htm
            long_press (bool): specify if simulate a long press for the key or not. Defaults to False.
        
        Returns:
            String of the output results of sending input.
        &#34;&#34;&#34;
        command = f&#39;input keyevent {keycode.name}&#39;
        if long_press:
            command += &#39;--longpress&#39;
        return self.execute_shell_command(command)
    
    
    
    def send_text_input(self, text: str, encode_spaces: bool=True):
        &#34;&#34;&#34;
        The function executes an adb shell command to send text input.
        
        Args:
            text (str): the text string to send.
            encode_spaces (bool): specify if spaces should be replaced by `%s` or not. Defaults to True.
        
        Returns:
            String of the output results of sending input.
        &#34;&#34;&#34;
        &#39;&#39;&#39;Send text.&#39;&#39;&#39;
        processed_text = text.replace(&#39; &#39;, &#39;%s&#39;) if encode_spaces else text
        return self.execute_shell_command(f&#39;input text {processed_text}&#39;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="AndroidTVController.adb_client.ADBClient.clean"><code class="name flex">
<span>def <span class="ident">clean</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Resets and clean</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clean(self):
    &#34;&#34;&#34;Resets and clean&#34;&#34;&#34;
    self.__devices = []
    self.__selected_device = None
    self.__server_process = None</code></pre>
</details>
</dd>
<dt id="AndroidTVController.adb_client.ADBClient.connect"><code class="name flex">
<span>def <span class="ident">connect</span></span>(<span>self, ip: str)</span>
</code></dt>
<dd>
<div class="desc"><p>The function connects to an IP address and raises an error if the connection fails.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ip</code></strong> :&ensp;<code>str</code></dt>
<dd>The <code>ip</code> parameter in the <code>connect</code> method is a string that represents the IP
address of the device you want to connect to.</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>RuntimeError</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def connect(self, ip: str):
    &#34;&#34;&#34;
    The function connects to an IP address and raises an error if the connection fails.
    
    Args:
        ip (str): The `ip` parameter in the `connect` method is a string that represents the IP
            address of the device you want to connect to.
            
    Raises:
        RuntimeError
    &#34;&#34;&#34;
    result = self.__execute_command(f&#39;connect {ip}&#39;)
    if &#34;failed&#34; in result:
        raise RuntimeError(f&#34;Unable to connect to {ip}&#34;)
    elif &#34;connected&#34; in result:
        self.__selected_device = self.get_serialno()</code></pre>
</details>
</dd>
<dt id="AndroidTVController.adb_client.ADBClient.disconnect"><code class="name flex">
<span>def <span class="ident">disconnect</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Disconnect device.</p>
<h2 id="returns">Returns</h2>
<p>String of the disconnect process result.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disconnect(self) -&gt; str:
    &#34;&#34;&#34;
    Disconnect device.
    
    Returns:
        String of the disconnect process result.
    &#34;&#34;&#34;
    return self.__execute_command(&#39;disconnect&#39;)</code></pre>
</details>
</dd>
<dt id="AndroidTVController.adb_client.ADBClient.execute_shell_command"><code class="name flex">
<span>def <span class="ident">execute_shell_command</span></span>(<span>self, command: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>The function executes an adb shell command by calling <code>adb shell</code> command.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>command</code></strong> :&ensp;<code>str</code></dt>
<dd>The <code>command</code> parameter is a string that represents the shell command that you
want to execute.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>String of the output results of executing the shell command.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def execute_shell_command(self, command: str) -&gt; str:
    &#34;&#34;&#34;
    The function executes an adb shell command by calling `adb shell` command.
    
    Args:
        command (str): The `command` parameter is a string that represents the shell command that you
            want to execute.
    
    Returns:
        String of the output results of executing the shell command.
    &#34;&#34;&#34;
    return self.__execute_command(f&#39;shell {command}&#39;)</code></pre>
</details>
</dd>
<dt id="AndroidTVController.adb_client.ADBClient.get_device_info"><code class="name flex">
<span>def <span class="ident">get_device_info</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>The function <code>get_device_info</code> retrieves device information.</p>
<h2 id="returns">Returns</h2>
<p>Dictionary containing device information.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_device_info(self) -&gt; dict:
    &#34;&#34;&#34;
    The function `get_device_info` retrieves device information.
    
    Returns:
        Dictionary containing device information.
    &#34;&#34;&#34;
    results = self.__execute_command(&#39;getprop&#39;).split(&#39;\n&#39;)
    device_info = {}
    for data in results:
        match = re.match(r&#34;\[([^:]+)\]: \[([^:]+)\]&#34;, data)
        if match:
            device_info[match.group(1)] = match.group(2)
    return device_info</code></pre>
</details>
</dd>
<dt id="AndroidTVController.adb_client.ADBClient.get_devices"><code class="name flex">
<span>def <span class="ident">get_devices</span></span>(<span>self, include_descriptions: bool = True) ‑> list</span>
</code></dt>
<dd>
<div class="desc"><p>The function <code>get_devices</code> retrieves a list of connected devices, including their IP address,
serial number, state, and optional descriptions.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>include_descriptions</code></strong> :&ensp;<code>bool</code></dt>
<dd>The <code>include_descriptions</code> parameter is a boolean flag that
determines whether or not to include descriptions for the connected devices. If set to <code>True</code>,
the descriptions will be included in the returned list of devices. If set to <code>False</code>, the
descriptions will be excluded. Defaults to True</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt>The method <code>get_devices</code> returns a list of dictionaries, where each dictionary represents a</dt>
<dt><code>connected device. Each dictionary contains the following keys</code></dt>
<dd>'ip', 'serial_number', 'state',</dd>
</dl>
<p>and 'description'.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_devices(self, include_descriptions: bool=True) -&gt; list:
    &#34;&#34;&#34;
    The function `get_devices` retrieves a list of connected devices, including their IP address,
    serial number, state, and optional descriptions.
    
    Args:
        include_descriptions (bool): The `include_descriptions` parameter is a boolean flag that
            determines whether or not to include descriptions for the connected devices. If set to `True`,
            the descriptions will be included in the returned list of devices. If set to `False`, the
            descriptions will be excluded. Defaults to True

    Returns:
        The method `get_devices` returns a list of dictionaries, where each dictionary represents a
        connected device. Each dictionary contains the following keys: &#39;ip&#39;, &#39;serial_number&#39;, &#39;state&#39;,
        and &#39;description&#39;.
    &#34;&#34;&#34;
    command = &#39;devices&#39;
    if include_descriptions:
        command += &#39; -l&#39;
    result = self.__execute_command(command)
    devices = result.split(&#34;\n&#34;)[1:]
    Logger.info(f&#39;There are {len(devices)} connected devices&#39;)
    for i, device in enumerate(devices):
        data = device.split()
        serial_number = data[0]
        ip = serial_number.split(&#39;:&#39;)[0]
        state = data[1]
        description = {}
        for meta in data[2:]:
            meta_pairs = meta.split(&#39;:&#39;)
            if len(meta_pairs) == 2:
                description[meta_pairs[0]] = meta_pairs[1]
        self.__devices.append({&#39;ip&#39;: ip, &#39;serial_number&#39;: serial_number, &#39;state&#39;: state, &#39;description&#39;: description})
        if self.__verbose:
            Logger.print(f&#39;[bold green]Device[/bold green]: [yellow]{i+1}[/yellow]&#39;)
            Logger.print(f&#39;[bold green]IP address[/bold green]: [yellow]{ip}[/yellow]&#39;)
            Logger.print(f&#39;[bold green]Serial number[/bold green]: [yellow]{serial_number}[/yellow]&#39;)
            Logger.print(f&#39;[bold green]State[/bold green]: [yellow]{state}[/yellow]&#39;)
            for key, val in description.items():
                Logger.print(f&#39;[bold green]{key.title()}[/bold green]: [yellow]{val}[/yellow]&#39;)
            Logger.print(&#39;\n&#39;)
    return self.__devices</code></pre>
</details>
</dd>
<dt id="AndroidTVController.adb_client.ADBClient.get_devpath"><code class="name flex">
<span>def <span class="ident">get_devpath</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>The function <code>get_devpath</code> retrieves the device path of a connected Android device'.</p>
<h2 id="returns">Returns</h2>
<p>String represents the device path, for example usb:1-4.3 for usb connected device.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_devpath(self) -&gt; str:
    &#34;&#34;&#34;
    The function `get_devpath` retrieves the device path of a connected Android device&#39;.
    
    Returns:
        String represents the device path, for example usb:1-4.3 for usb connected device.
    &#34;&#34;&#34;
    return self.__execute_command(&#39;get-devpath&#39;)</code></pre>
</details>
</dd>
<dt id="AndroidTVController.adb_client.ADBClient.get_ip_address"><code class="name flex">
<span>def <span class="ident">get_ip_address</span></span>(<span>self, interface: str = 'wlan0') ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>The function <code>get_ip_address</code> returns the device IP address of a specified network interface.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>interface</code></strong> :&ensp;<code>str</code></dt>
<dd>The <code>interface</code> parameter is a string that specifies the network interface to
retrieve the IP address from. In this case, the default value is set to "wlan0", which is a
common interface name for wireless LAN connections on Linux-based systems. Defaults to wlan0</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The IP address of the selected device.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_ip_address(self, interface: str=&#39;wlan0&#39;) -&gt; Any:
    &#34;&#34;&#34;
    The function `get_ip_address` returns the device IP address of a specified network interface.
    
    Args:
        interface (str): The `interface` parameter is a string that specifies the network interface to
            retrieve the IP address from. In this case, the default value is set to &#34;wlan0&#34;, which is a
            common interface name for wireless LAN connections on Linux-based systems. Defaults to wlan0
    
    Returns:
        The IP address of the selected device.
    &#34;&#34;&#34;
    if self.__selected_device is not None:
        return self.__selected_device.split(&#39;:&#39;)[0]
    # if result := self.execute_shell_command(f&#39;ifconfig {interface}&#39;):
    #     if match_obj := re.search(r&#34;inet addr:(.+)  Bcast&#34;, result, re.M | re.I):
    #         return match_obj[1]</code></pre>
</details>
</dd>
<dt id="AndroidTVController.adb_client.ADBClient.get_package_activities"><code class="name flex">
<span>def <span class="ident">get_package_activities</span></span>(<span>self, package: str) ‑> list</span>
</code></dt>
<dd>
<div class="desc"><p>The function <code>get_package_activities</code> retrieves the activities associated with a given package
in order to start the app.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>package</code></strong> :&ensp;<code>str</code></dt>
<dd>The "package" parameter is a string that represents the name of the package for
which you want to retrieve the activities.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>List of package activities.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_package_activities(self, package: str) -&gt; list:
    &#34;&#34;&#34;
    The function `get_package_activities` retrieves the activities associated with a given package
    in order to start the app.
    
    Args:
        package (str): The &#34;package&#34; parameter is a string that represents the name of the package for
            which you want to retrieve the activities.
    
    Returns:
        List of package activities.
    &#34;&#34;&#34;
    &#39;&#39;&#39;Get package activities, this is useful to be able to start the app&#39;&#39;&#39;
    results = self.execute_shell_command(f&#39;dumpsys package {package}&#39;).split()
    activities = set()
    for res in results:
        if &#39;activity&#39; in res.lower() and &#39;com&#39; in res.lower():
            activities.add(res.replace(&#39;&#34;&#39;, &#39;&#39;).strip())
    return list(activities)</code></pre>
</details>
</dd>
<dt id="AndroidTVController.adb_client.ADBClient.get_serialno"><code class="name flex">
<span>def <span class="ident">get_serialno</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>The function <code>get_serialno</code> returns the serial number of a selected device.</p>
<h2 id="returns">Returns</h2>
<p>The method is returning the serial number of the selected device.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_serialno(self) -&gt; str:
    &#34;&#34;&#34;
    The function `get_serialno` returns the serial number of a selected device.
    
    Returns:
        The method is returning the serial number of the selected device.
    &#34;&#34;&#34;
    if self.__selected_device:
        return self.__selected_device
    self.__selected_device = self.__execute_command(&#39;get-serialno&#39;)
    return self.__selected_device</code></pre>
</details>
</dd>
<dt id="AndroidTVController.adb_client.ADBClient.get_state"><code class="name flex">
<span>def <span class="ident">get_state</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>The function <code>get_state</code> returns the state of connected device.</p>
<h2 id="returns">Returns</h2>
<p>String represents device state.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_state(self) -&gt; str:
    &#34;&#34;&#34;
    The function `get_state` returns the state of connected device.
    
    Returns:
        String represents device state.
    &#34;&#34;&#34;
    return self.__execute_command(&#39;get-state&#39;)</code></pre>
</details>
</dd>
<dt id="AndroidTVController.adb_client.ADBClient.install"><code class="name flex">
<span>def <span class="ident">install</span></span>(<span>self, apk_file: str, replace: bool = True) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>The function installs an APK file on a device, with an option to replace/update an existing
installation.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>apk_file</code></strong> :&ensp;<code>str</code></dt>
<dd>The <code>apk_file</code> parameter is a string that represents the file path of the APK
file that you want to install.</dd>
<dt><strong><code>replace</code></strong> :&ensp;<code>bool</code></dt>
<dd>The <code>replace</code> parameter is a boolean value that determines whether to replace
an existing installation of the APK file. If <code>replace</code> is set to <code>True</code>, the existing
installation will be replaced. If <code>replace</code> is set to <code>False</code>, the existing installation will
not be replaced and an error will. Defaults to True</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>String of the app installation process result.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def install(self, apk_file: str, replace: bool=True) -&gt; str:
    &#34;&#34;&#34;
    The function installs an APK file on a device, with an option to replace/update an existing
    installation.
    
    Args:
        apk_file (str): The `apk_file` parameter is a string that represents the file path of the APK
            file that you want to install.
        replace (bool): The `replace` parameter is a boolean value that determines whether to replace
            an existing installation of the APK file. If `replace` is set to `True`, the existing
            installation will be replaced. If `replace` is set to `False`, the existing installation will
            not be replaced and an error will. Defaults to True
    
    Returns:
        String of the app installation process result.
    &#34;&#34;&#34;
    command = &#39;install &#39;
    if replace:
        command += &#39;-r &#39;
    command += apk_file
    return self.__execute_command(command)</code></pre>
</details>
</dd>
<dt id="AndroidTVController.adb_client.ADBClient.is_connected"><code class="name flex">
<span>def <span class="ident">is_connected</span></span>(<span>self, ip: str) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>The function checks if a device with a given IP address is connected to adb server.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ip</code></strong> :&ensp;<code>str</code></dt>
<dd>The <code>ip</code> parameter is a string that represents an IP address.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Boolean value. It returns True if there is a device in the list of devices with the
specified IP address, and False otherwise.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_connected(self, ip: str) -&gt; bool:
    &#34;&#34;&#34;
    The function checks if a device with a given IP address is connected to adb server.
    
    Args:
        ip (str): The `ip` parameter is a string that represents an IP address.
    
    Returns:
        Boolean value. It returns True if there is a device in the list of devices with the
        specified IP address, and False otherwise.
    &#34;&#34;&#34;
    for device in self.__devices:
        if device[&#39;ip&#39;] == ip:
            return True
    return False</code></pre>
</details>
</dd>
<dt id="AndroidTVController.adb_client.ADBClient.is_installed"><code class="name flex">
<span>def <span class="ident">is_installed</span></span>(<span>self, package_name: str) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>The function checks if the specified package is installed or not.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>package_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the package, for example 'com.google.chrome'</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Boolean indicates if app is installed or not.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_installed(self, package_name: str) -&gt; bool:
    &#34;&#34;&#34;
    The function checks if the specified package is installed or not.
    
    Args:
        package_name (str): The name of the package, for example &#39;com.google.chrome&#39;
    
    Returns:
        Boolean indicates if app is installed or not.
    &#34;&#34;&#34;
    command = f&#39;pm list packages | grep {package_name}&#39;
    return len(self.execute_shell_command(command)) &gt; 0</code></pre>
</details>
</dd>
<dt id="AndroidTVController.adb_client.ADBClient.kill_server"><code class="name flex">
<span>def <span class="ident">kill_server</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>The function <code>kill_server</code> stops the ADB server and terminates any running server process.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def kill_server(self):
    &#34;&#34;&#34;
    The function `kill_server` stops the ADB server and terminates any running server process.
    &#34;&#34;&#34;
    command = &#39;kill-server&#39;
    self.__execute_command(command)
    if self.__server_process:
        self.__server_process.terminate()
    self.clean()
    if self.__verbose:
        Logger.success(&#39;ADB server is stopped&#39;)</code></pre>
</details>
</dd>
<dt id="AndroidTVController.adb_client.ADBClient.list_packages"><code class="name flex">
<span>def <span class="ident">list_packages</span></span>(<span>self, package_type: str = 'all') ‑> list</span>
</code></dt>
<dd>
<div class="desc"><p>The function "list_packages" lists device android packages, you can also filter package type.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>package_type</code></strong> :&ensp;<code>str</code></dt>
<dd>The <code>package_type</code> parameter is a string that specifies the type of
packages to list. It has a default value of <code>all</code> that gets all packages on the device,
but it can also take the following values: [all | enabled | disabled | system | third-party].
Defaults to all</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>List of packages.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list_packages(self, package_type: str=&#39;all&#39;) -&gt; list:
    &#34;&#34;&#34;
    The function &#34;list_packages&#34; lists device android packages, you can also filter package type.
    
    Args:
        package_type (str): The `package_type` parameter is a string that specifies the type of
            packages to list. It has a default value of `all` that gets all packages on the device,
            but it can also take the following values: [all | enabled | disabled | system | third-party].
            Defaults to all
    
    Returns:
        List of packages.
    &#34;&#34;&#34;
    package_type_flags = {&#39;all&#39;: &#39;&#39;, &#39;enabled&#39;: &#39;-e&#39;, &#39;disabled&#39;: &#39;-d&#39;, &#39;system&#39;: &#39;-s&#39;, &#39;third-party&#39;: &#39;-3&#39;}
    if package_type not in package_type_flags:
        package_type = &#39;all&#39;
    results = self.execute_shell_command(f&#39;pm list packages {package_type_flags[package_type]}&#39;).split(&#34;\n&#34;)
    packages = sorted([x.replace(&#39;package:&#39;, &#39;&#39;) for x in results])
    if self.__verbose:
        for package in packages:
            Logger.print(f&#39;[bold green]{package}[/bold green]&#39;)
    return packages</code></pre>
</details>
</dd>
<dt id="AndroidTVController.adb_client.ADBClient.list_services"><code class="name flex">
<span>def <span class="ident">list_services</span></span>(<span>self) ‑> list</span>
</code></dt>
<dd>
<div class="desc"><p>The <code>list_services</code> function retrieves a list of services along with their IDs, names, and
associated packages.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt>List of dictionaries, where each dictionary represents a service. Each dictionary contains</dt>
<dt><code>the following keys</code></dt>
<dd>'id' (integer), 'name' (string), and 'package' (string).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list_services(self) -&gt; list:
    &#34;&#34;&#34;
    The `list_services` function retrieves a list of services along with their IDs, names, and
    associated packages.
    
    Returns:
        List of dictionaries, where each dictionary represents a service. Each dictionary contains
        the following keys: &#39;id&#39; (integer), &#39;name&#39; (string), and &#39;package&#39; (string).
    &#34;&#34;&#34;
    results = self.execute_shell_command(&#39;service list&#39;)
    lines = results.split(&#34;\n&#34;)
    lines = lines[1:]
    services = []
    pattern = r&#34;(\d+)\t(\w+):\s+\[(.*?)\]&#34;
    for line in lines:
        if match := re.search(pattern, line):
            service_id = int(match[1])
            service_name = match[2]
            service_process = match[3]
            service_info = {&#39;id&#39;: service_id, &#39;name&#39;: service_name, &#39;package&#39;: service_process}
            services.append(service_info)
    return services</code></pre>
</details>
</dd>
<dt id="AndroidTVController.adb_client.ADBClient.pull"><code class="name flex">
<span>def <span class="ident">pull</span></span>(<span>self, remote: str, local: str, preserve_meta: bool = False) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>The function <code>pull</code> copies remote files and directories to a device, with an option to preserve
file metadata like time stamp and mode.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>remote</code></strong> :&ensp;<code>str</code></dt>
<dd>The <code>remote</code> parameter is a string that represents the path of the remote file
or directory that you want to copy to the device.</dd>
<dt><strong><code>local</code></strong> :&ensp;<code>str</code></dt>
<dd>The "local" parameter is a string that represents the local directory or file
path where the remote files and directories will be copied to.</dd>
<dt><strong><code>preserve_meta</code></strong> :&ensp;<code>bool</code></dt>
<dd>The <code>preserve_meta</code> parameter is a boolean flag that determines whether
to preserve the file time stamp and mode during the file transfer process. If <code>preserve_meta</code> is
set to <code>True</code>, the <code>-k</code> option will be added to the command, indicating that the file time stamp
and mode should be. Defaults to False</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>String of the file download process result.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pull(self, remote: str, local: str, preserve_meta: bool=False) -&gt; str:
    &#34;&#34;&#34;
    The function `pull` copies remote files and directories to a device, with an option to preserve
    file metadata like time stamp and mode.
    
    Args:
        remote (str): The `remote` parameter is a string that represents the path of the remote file
            or directory that you want to copy to the device.
        local (str): The &#34;local&#34; parameter is a string that represents the local directory or file
            path where the remote files and directories will be copied to.
        preserve_meta (bool): The `preserve_meta` parameter is a boolean flag that determines whether
            to preserve the file time stamp and mode during the file transfer process. If `preserve_meta` is
            set to `True`, the `-k` option will be added to the command, indicating that the file time stamp
            and mode should be. Defaults to False
    
    Returns:
        String of the file download process result.
    &#34;&#34;&#34;
    command = &#39;pull &#39;
    if preserve_meta:
        command += &#39;-k &#39;
    command += f&#39;{remote} {local}&#39;
    return self.__execute_command(command)</code></pre>
</details>
</dd>
<dt id="AndroidTVController.adb_client.ADBClient.push"><code class="name flex">
<span>def <span class="ident">push</span></span>(<span>self, local: str, remote: str = '/data/local/tmp/') ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Copy files and directories from the local device (computer) to
a remote location on the device.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>local</code></strong> :&ensp;<code>str</code></dt>
<dd>The <code>local</code> parameter is a string that represents the path of the file or
directory on the local device (computer) that you want to copy to the remote location on the
device.</dd>
<dt><strong><code>remote</code></strong> :&ensp;<code>str</code></dt>
<dd>The <code>remote</code> parameter is a string that specifies the destination location on
the device where the files or directories from the local device will be copied to. By default,
the destination location is set to <code>/data/local/tmp/</code>, but you can provide a different path if
needed. Defaults to /data/local/tmp/</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>String of the file upload process result.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def push(self, local: str, remote: str=&#39;/data/local/tmp/&#39;) -&gt; str:
    &#34;&#34;&#34;
    Copy files and directories from the local device (computer) to
    a remote location on the device.
    
    Args:
        local (str): The `local` parameter is a string that represents the path of the file or
            directory on the local device (computer) that you want to copy to the remote location on the
            device.
        remote (str): The `remote` parameter is a string that specifies the destination location on
            the device where the files or directories from the local device will be copied to. By default,
            the destination location is set to `/data/local/tmp/`, but you can provide a different path if
            needed. Defaults to /data/local/tmp/
    
    Returns:
        String of the file upload process result.
    &#34;&#34;&#34;
    return self.__execute_command(f&#39;push {local} {remote}&#39;)</code></pre>
</details>
</dd>
<dt id="AndroidTVController.adb_client.ADBClient.reboot"><code class="name flex">
<span>def <span class="ident">reboot</span></span>(<span>self, mode: str | None = None) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>The function <code>reboot</code> reboots the device with the specified mode, or with no mode if none is
provided.</p>
<h2 id="args">Args</h2>
<p>mode (str|None): The <code>mode</code> parameter is a string that specifies the type of reboot to
perform. It can have one of the following values: [bootloader | recovery | sideload | sideload-auto-reboot]</p>
<h2 id="returns">Returns</h2>
<p>The method is returning the result of executing the reboot command on the device.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reboot(self, mode: str|None=None) -&gt; str:
    &#34;&#34;&#34;
    The function `reboot` reboots the device with the specified mode, or with no mode if none is
    provided.
    
    Args:
        mode (str|None): The `mode` parameter is a string that specifies the type of reboot to
            perform. It can have one of the following values: [bootloader | recovery | sideload | sideload-auto-reboot]
    
    Returns:
        The method is returning the result of executing the reboot command on the device.
    &#34;&#34;&#34;
    command = &#39;reboot &#39;
    if mode:
        command += mode
    return self.__execute_command(command)</code></pre>
</details>
</dd>
<dt id="AndroidTVController.adb_client.ADBClient.select_device"><code class="name flex">
<span>def <span class="ident">select_device</span></span>(<span>self, device_serial: str)</span>
</code></dt>
<dd>
<div class="desc"><p>The function selects a device based on its serial number.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>device_serial</code></strong> :&ensp;<code>str</code></dt>
<dd>The <code>device_serial</code> parameter is a string that represents the serial
number of a device.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def select_device(self, device_serial: str):
    &#34;&#34;&#34;
    The function selects a device based on its serial number.
    
    Args:
        device_serial (str): The `device_serial` parameter is a string that represents the serial
            number of a device.
    &#34;&#34;&#34;
    self.__selected_device = device_serial</code></pre>
</details>
</dd>
<dt id="AndroidTVController.adb_client.ADBClient.send_keyevent_input"><code class="name flex">
<span>def <span class="ident">send_keyevent_input</span></span>(<span>self, keycode: <a title="AndroidTVController.key_codes.KeyCodes" href="key_codes.html#AndroidTVController.key_codes.KeyCodes">KeyCodes</a>, long_press: bool = False) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>The function executes an adb shell command to send key event input that simulates pressing button keys.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>keycode</code></strong> :&ensp;<code>KeyCode</code></dt>
<dd>the keycode to send, table of key codes: <a href="https://www.temblast.com/ref/akeyscode.htm">https://www.temblast.com/ref/akeyscode.htm</a></dd>
<dt><strong><code>long_press</code></strong> :&ensp;<code>bool</code></dt>
<dd>specify if simulate a long press for the key or not. Defaults to False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>String of the output results of sending input.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_keyevent_input(self, keycode: KeyCodes, long_press: bool=False) -&gt; str:
    &#34;&#34;&#34;
    The function executes an adb shell command to send key event input that simulates pressing button keys.
    
    Args:
        keycode (KeyCode): the keycode to send, table of key codes: https://www.temblast.com/ref/akeyscode.htm
        long_press (bool): specify if simulate a long press for the key or not. Defaults to False.
    
    Returns:
        String of the output results of sending input.
    &#34;&#34;&#34;
    command = f&#39;input keyevent {keycode.name}&#39;
    if long_press:
        command += &#39;--longpress&#39;
    return self.execute_shell_command(command)</code></pre>
</details>
</dd>
<dt id="AndroidTVController.adb_client.ADBClient.send_text_input"><code class="name flex">
<span>def <span class="ident">send_text_input</span></span>(<span>self, text: str, encode_spaces: bool = True)</span>
</code></dt>
<dd>
<div class="desc"><p>The function executes an adb shell command to send text input.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>text</code></strong> :&ensp;<code>str</code></dt>
<dd>the text string to send.</dd>
<dt><strong><code>encode_spaces</code></strong> :&ensp;<code>bool</code></dt>
<dd>specify if spaces should be replaced by <code>%s</code> or not. Defaults to True.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>String of the output results of sending input.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_text_input(self, text: str, encode_spaces: bool=True):
    &#34;&#34;&#34;
    The function executes an adb shell command to send text input.
    
    Args:
        text (str): the text string to send.
        encode_spaces (bool): specify if spaces should be replaced by `%s` or not. Defaults to True.
    
    Returns:
        String of the output results of sending input.
    &#34;&#34;&#34;
    &#39;&#39;&#39;Send text.&#39;&#39;&#39;
    processed_text = text.replace(&#39; &#39;, &#39;%s&#39;) if encode_spaces else text
    return self.execute_shell_command(f&#39;input text {processed_text}&#39;)</code></pre>
</details>
</dd>
<dt id="AndroidTVController.adb_client.ADBClient.start_app"><code class="name flex">
<span>def <span class="ident">start_app</span></span>(<span>self, package: str, activity: str, wait: bool = True, stop: bool = True) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>The function starts an Android app with the specified package and activity, optionally waiting
for the launch to complete and stopping the app before starting the activity.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>package</code></strong> :&ensp;<code>str</code></dt>
<dd>The package parameter is a string that represents the package name of the
Android application you want to start. This is typically the unique identifier for the app and
is specified in the AndroidManifest.xml file of the app.</dd>
<dt><strong><code>activity</code></strong> :&ensp;<code>str</code></dt>
<dd>The "activity" parameter refers to the specific activity or screen within the
Android app that you want to start. An activity represents a single screen with a user
interface, and it is the basic building block of an Android app. Each activity has a unique name
that is specified in the AndroidManifest.xml file</dd>
<dt><strong><code>wait</code></strong> :&ensp;<code>bool</code></dt>
<dd>The "wait" parameter is a boolean value that determines whether the command
should wait for the launch to complete before returning. If set to True, the command will wait
for the launch to complete. If set to False, the command will not wait and will return
immediately after starting the activity. Defaults to True</dd>
<dt><strong><code>stop</code></strong> :&ensp;<code>bool</code></dt>
<dd>The "stop" parameter is a boolean value that determines whether to force stop the
target app before starting the activity. If it is set to True, the target app will be stopped
before starting the activity. If it is set to False, the target app will not be stopped.
Defaults to True</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>String of the app launch process result.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start_app(self, package: str, activity: str, wait: bool=True, stop: bool=True) -&gt; str:
    &#34;&#34;&#34;
    The function starts an Android app with the specified package and activity, optionally waiting
    for the launch to complete and stopping the app before starting the activity.
    
    Args:
        package (str): The package parameter is a string that represents the package name of the
            Android application you want to start. This is typically the unique identifier for the app and
            is specified in the AndroidManifest.xml file of the app.
        activity (str): The &#34;activity&#34; parameter refers to the specific activity or screen within the
            Android app that you want to start. An activity represents a single screen with a user
            interface, and it is the basic building block of an Android app. Each activity has a unique name
            that is specified in the AndroidManifest.xml file
        wait (bool): The &#34;wait&#34; parameter is a boolean value that determines whether the command
            should wait for the launch to complete before returning. If set to True, the command will wait
            for the launch to complete. If set to False, the command will not wait and will return
            immediately after starting the activity. Defaults to True
        stop (bool): The &#34;stop&#34; parameter is a boolean value that determines whether to force stop the
            target app before starting the activity. If it is set to True, the target app will be stopped
            before starting the activity. If it is set to False, the target app will not be stopped.
            Defaults to True
    
    Returns:
        String of the app launch process result.
    &#34;&#34;&#34;
    command = &#39;am start &#39;
    # wait for launch to complete
    if wait:
        command += &#39;-W &#39;
    if stop: # force stop the target app before starting the activity
        command += &#39;-S &#39;
    command += f&#39;{package}/{activity}&#39;
    return self.execute_shell_command(command)</code></pre>
</details>
</dd>
<dt id="AndroidTVController.adb_client.ADBClient.start_server"><code class="name flex">
<span>def <span class="ident">start_server</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>The function starts an ADB server and waits for it to start up.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start_server(self):
    &#34;&#34;&#34;
    The function starts an ADB server and waits for it to start up.
    &#34;&#34;&#34;
    command = &#39;start-server&#39;
    if self.__verbose:
        Logger.success(&#39;ADB server is started&#39;)
    self.__server_process = self.__execute_command(command, False)
    time.sleep(5) # give time to start up</code></pre>
</details>
</dd>
<dt id="AndroidTVController.adb_client.ADBClient.start_service"><code class="name flex">
<span>def <span class="ident">start_service</span></span>(<span>self, service: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>The function executes an adb shell command to start a service.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>service</code></strong> :&ensp;<code>str</code></dt>
<dd>The <code>service</code> parameter is a string that represents service name that you
want to start.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>String of the output results of service starting processing.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start_service(self, service: str) -&gt; str:
    &#34;&#34;&#34;
    The function executes an adb shell command to start a service.
    
    Args:
        service (str): The `service` parameter is a string that represents service name that you
            want to start.
    
    Returns:
        String of the output results of service starting processing.
    &#34;&#34;&#34;
    return self.execute_shell_command(f&#39;am startservice {service}&#39;)</code></pre>
</details>
</dd>
<dt id="AndroidTVController.adb_client.ADBClient.stop_app"><code class="name flex">
<span>def <span class="ident">stop_app</span></span>(<span>self, package: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>The function stops an Android app with the specified package.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>package</code></strong> :&ensp;<code>str</code></dt>
<dd>The package parameter is a string that represents the package name of the app
you want to stop.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>String of the app stopping process result.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop_app(self, package: str) -&gt; str:
    &#34;&#34;&#34;
    The function stops an Android app with the specified package.
    
    Args:
        package (str): The package parameter is a string that represents the package name of the app
            you want to stop.
    
    Returns:
        String of the app stopping process result.
    &#34;&#34;&#34;
    return self.execute_shell_command(f&#39;am force-stop {package}&#39;)</code></pre>
</details>
</dd>
<dt id="AndroidTVController.adb_client.ADBClient.stop_service"><code class="name flex">
<span>def <span class="ident">stop_service</span></span>(<span>self, service: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>The function executes an adb shell command to stop a running service.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>service</code></strong> :&ensp;<code>str</code></dt>
<dd>The <code>service</code> parameter is a string that represents service name that you
want to stop.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>String of the output results of service stopping processing.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop_service(self, service: str) -&gt; str:
    &#34;&#34;&#34;
    The function executes an adb shell command to stop a running service.
    
    Args:
        service (str): The `service` parameter is a string that represents service name that you
            want to stop.
    
    Returns:
        String of the output results of service stopping processing.
    &#34;&#34;&#34;
    return self.execute_shell_command(f&#39;am stopservice {service}&#39;)
    # return self.execute_shell_command(f&#39;am force-stop {service}&#39;)</code></pre>
</details>
</dd>
<dt id="AndroidTVController.adb_client.ADBClient.uninstall"><code class="name flex">
<span>def <span class="ident">uninstall</span></span>(<span>self, package: str, keep_data: bool = False) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>The <code>uninstall</code> function removes an app package from a device, with an option to keep the data
and cache directories.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>package</code></strong> :&ensp;<code>str</code></dt>
<dd>The package parameter is a string that represents the app package name that you
want to uninstall from the device.</dd>
<dt><strong><code>keep_data</code></strong> :&ensp;<code>bool</code></dt>
<dd>A boolean parameter that determines whether to keep the data and cache
directories of the app package when uninstalling. If set to True, the directories will be kept.
If set to False (default), the directories will be removed along with the app package. Defaults
to False</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>String of the app removal process result.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def uninstall(self, package: str, keep_data: bool=False) -&gt; str:
    &#34;&#34;&#34;
    The `uninstall` function removes an app package from a device, with an option to keep the data
    and cache directories.
    
    Args:
        package (str): The package parameter is a string that represents the app package name that you
            want to uninstall from the device.
        keep_data (bool): A boolean parameter that determines whether to keep the data and cache
            directories of the app package when uninstalling. If set to True, the directories will be kept.
            If set to False (default), the directories will be removed along with the app package. Defaults
            to False
    
    Returns:
        String of the app removal process result.
    &#34;&#34;&#34;
    command = &#39;uninstall &#39;
    if keep_data:
        command += &#39;-k &#39;
    command += package
    return self.__execute_command(command)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="AndroidTVController" href="index.html">AndroidTVController</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="AndroidTVController.adb_client.ADBClient" href="#AndroidTVController.adb_client.ADBClient">ADBClient</a></code></h4>
<ul class="">
<li><code><a title="AndroidTVController.adb_client.ADBClient.clean" href="#AndroidTVController.adb_client.ADBClient.clean">clean</a></code></li>
<li><code><a title="AndroidTVController.adb_client.ADBClient.connect" href="#AndroidTVController.adb_client.ADBClient.connect">connect</a></code></li>
<li><code><a title="AndroidTVController.adb_client.ADBClient.disconnect" href="#AndroidTVController.adb_client.ADBClient.disconnect">disconnect</a></code></li>
<li><code><a title="AndroidTVController.adb_client.ADBClient.execute_shell_command" href="#AndroidTVController.adb_client.ADBClient.execute_shell_command">execute_shell_command</a></code></li>
<li><code><a title="AndroidTVController.adb_client.ADBClient.get_device_info" href="#AndroidTVController.adb_client.ADBClient.get_device_info">get_device_info</a></code></li>
<li><code><a title="AndroidTVController.adb_client.ADBClient.get_devices" href="#AndroidTVController.adb_client.ADBClient.get_devices">get_devices</a></code></li>
<li><code><a title="AndroidTVController.adb_client.ADBClient.get_devpath" href="#AndroidTVController.adb_client.ADBClient.get_devpath">get_devpath</a></code></li>
<li><code><a title="AndroidTVController.adb_client.ADBClient.get_ip_address" href="#AndroidTVController.adb_client.ADBClient.get_ip_address">get_ip_address</a></code></li>
<li><code><a title="AndroidTVController.adb_client.ADBClient.get_package_activities" href="#AndroidTVController.adb_client.ADBClient.get_package_activities">get_package_activities</a></code></li>
<li><code><a title="AndroidTVController.adb_client.ADBClient.get_serialno" href="#AndroidTVController.adb_client.ADBClient.get_serialno">get_serialno</a></code></li>
<li><code><a title="AndroidTVController.adb_client.ADBClient.get_state" href="#AndroidTVController.adb_client.ADBClient.get_state">get_state</a></code></li>
<li><code><a title="AndroidTVController.adb_client.ADBClient.install" href="#AndroidTVController.adb_client.ADBClient.install">install</a></code></li>
<li><code><a title="AndroidTVController.adb_client.ADBClient.is_connected" href="#AndroidTVController.adb_client.ADBClient.is_connected">is_connected</a></code></li>
<li><code><a title="AndroidTVController.adb_client.ADBClient.is_installed" href="#AndroidTVController.adb_client.ADBClient.is_installed">is_installed</a></code></li>
<li><code><a title="AndroidTVController.adb_client.ADBClient.kill_server" href="#AndroidTVController.adb_client.ADBClient.kill_server">kill_server</a></code></li>
<li><code><a title="AndroidTVController.adb_client.ADBClient.list_packages" href="#AndroidTVController.adb_client.ADBClient.list_packages">list_packages</a></code></li>
<li><code><a title="AndroidTVController.adb_client.ADBClient.list_services" href="#AndroidTVController.adb_client.ADBClient.list_services">list_services</a></code></li>
<li><code><a title="AndroidTVController.adb_client.ADBClient.pull" href="#AndroidTVController.adb_client.ADBClient.pull">pull</a></code></li>
<li><code><a title="AndroidTVController.adb_client.ADBClient.push" href="#AndroidTVController.adb_client.ADBClient.push">push</a></code></li>
<li><code><a title="AndroidTVController.adb_client.ADBClient.reboot" href="#AndroidTVController.adb_client.ADBClient.reboot">reboot</a></code></li>
<li><code><a title="AndroidTVController.adb_client.ADBClient.select_device" href="#AndroidTVController.adb_client.ADBClient.select_device">select_device</a></code></li>
<li><code><a title="AndroidTVController.adb_client.ADBClient.send_keyevent_input" href="#AndroidTVController.adb_client.ADBClient.send_keyevent_input">send_keyevent_input</a></code></li>
<li><code><a title="AndroidTVController.adb_client.ADBClient.send_text_input" href="#AndroidTVController.adb_client.ADBClient.send_text_input">send_text_input</a></code></li>
<li><code><a title="AndroidTVController.adb_client.ADBClient.start_app" href="#AndroidTVController.adb_client.ADBClient.start_app">start_app</a></code></li>
<li><code><a title="AndroidTVController.adb_client.ADBClient.start_server" href="#AndroidTVController.adb_client.ADBClient.start_server">start_server</a></code></li>
<li><code><a title="AndroidTVController.adb_client.ADBClient.start_service" href="#AndroidTVController.adb_client.ADBClient.start_service">start_service</a></code></li>
<li><code><a title="AndroidTVController.adb_client.ADBClient.stop_app" href="#AndroidTVController.adb_client.ADBClient.stop_app">stop_app</a></code></li>
<li><code><a title="AndroidTVController.adb_client.ADBClient.stop_service" href="#AndroidTVController.adb_client.ADBClient.stop_service">stop_service</a></code></li>
<li><code><a title="AndroidTVController.adb_client.ADBClient.uninstall" href="#AndroidTVController.adb_client.ADBClient.uninstall">uninstall</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>